{
  "00-Abstract": {
    "slug": "00-Abstract",
    "content": "# 0. Abstract\nThe current stratum protocol (v1) is used prevalently throughout the cryptocurrency mining industry today, but it was never intended nor designed to be an industry standard.   \n\nThis document proposes a new version of stratum protocol that addresses scaling and quality issues of the previous version, focusing on more efficient data transfers (i.e. distribution of mining jobs and result submissions) as well as increased security.\n\nAdditionally, the redesigned protocol includes support for transaction selection by the miners themselves, as opposed to the current version of the protocol in which only the pool operators can determine a new block’s transaction set.\n\nThere are some trade offs necessary to make the protocol scalable and relatively simple, which will be addressed in the detailed discussions below.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC2119.\n\nWe keep the name \"Stratum\" so that people will recognize that this is an upgrade of the widespread protocol version 1, with the hope that it will help gather support for the new version more easily. \n",
    "html": "<h1>0. Abstract</h1>\n<p>The current stratum protocol (v1) is used prevalently throughout the cryptocurrency mining industry today, but it was never intended nor designed to be an industry standard.</p>\n<p>This document proposes a new version of stratum protocol that addresses scaling and quality issues of the previous version, focusing on more efficient data transfers (i.e. distribution of mining jobs and result submissions) as well as increased security.</p>\n<p>Additionally, the redesigned protocol includes support for transaction selection by the miners themselves, as opposed to the current version of the protocol in which only the pool operators can determine a new block’s transaction set.</p>\n<p>There are some trade offs necessary to make the protocol scalable and relatively simple, which will be addressed in the detailed discussions below.</p>\n<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC2119.</p>\n<p>We keep the name “Stratum” so that people will recognize that this is an upgrade of the widespread protocol version 1, with the hope that it will help gather support for the new version more easily.</p>\n"
  },
  "01-Motivation": {
    "slug": "01-Motivation",
    "content": "# 1. Motivation\nStratum protocol v1 is JSON-based and lacks cryptographic authentication, making it slower, heavier, and less secure than it can be considering the alternatives available today.\nGiven the cryptocurrency mining industry’s continued maturation and growth, it’s necessary to address v1’s deficiencies and move to a more efficient solution with a precise definition.\n\nOne of the primary motivations of the new protocol is to reduce the amount and respective size of data transfers between miners, proxies, and pool operators to an absolute minimum.\nThis will enable stratum servers to use the saved bandwidth for higher submission rates, thus yielding a reduced variance in hash rate (and in turn in miner payouts).\n\nTo increase efficiency further, we will enable a simplified mode for end mining devices which completely eliminates the need for extranonce and Merkle path handling (i.e. any coinbase modification on downstream machines).\nThis mode, called header-only mining, makes computations simpler for miners and work validation much lighter on the server side.\nFurthermore, header-only mining reduces the cost of future changes to the Bitcoin protocol, as mining firmware and protocols do not need to be upgraded in conjunction with full nodes.\n\nIn terms of security, another important improvement to make is hardening the protocol against man-in-the-middle attacks by providing a way for mining devices to verify the integrity of the assigned mining jobs and other commands.\n\nLast but not the least, this protocol strives to allow downstream nodes to choose mining jobs and efficiently communicate them to upstream nodes to reduce power currently held by mining pools (block version selection, transaction selection). This should be possible without harming public pool business models or otherwise leading to more centralization in another area of the mining industry. \n",
    "html": "<h1>1. Motivation</h1>\n<p>Stratum protocol v1 is JSON-based and lacks cryptographic authentication, making it slower, heavier, and less secure than it can be considering the alternatives available today.\nGiven the cryptocurrency mining industry’s continued maturation and growth, it’s necessary to address v1’s deficiencies and move to a more efficient solution with a precise definition.</p>\n<p>One of the primary motivations of the new protocol is to reduce the amount and respective size of data transfers between miners, proxies, and pool operators to an absolute minimum.\nThis will enable stratum servers to use the saved bandwidth for higher submission rates, thus yielding a reduced variance in hash rate (and in turn in miner payouts).</p>\n<p>To increase efficiency further, we will enable a simplified mode for end mining devices which completely eliminates the need for extranonce and Merkle path handling (i.e. any coinbase modification on downstream machines).\nThis mode, called header-only mining, makes computations simpler for miners and work validation much lighter on the server side.\nFurthermore, header-only mining reduces the cost of future changes to the Bitcoin protocol, as mining firmware and protocols do not need to be upgraded in conjunction with full nodes.</p>\n<p>In terms of security, another important improvement to make is hardening the protocol against man-in-the-middle attacks by providing a way for mining devices to verify the integrity of the assigned mining jobs and other commands.</p>\n<p>Last but not the least, this protocol strives to allow downstream nodes to choose mining jobs and efficiently communicate them to upstream nodes to reduce power currently held by mining pools (block version selection, transaction selection). This should be possible without harming public pool business models or otherwise leading to more centralization in another area of the mining industry.</p>\n"
  },
  "02-Design-Goals": {
    "slug": "02-Design-Goals",
    "content": "# 2. Design Goals\nAs there are numerous changes from the original Stratum v1 to v2, it may be helpful to briefly review some high-level design goals before getting into more detailed technical specifications:\n\n- Develop a binary protocol with a precise definition.\n  Despite its simplicity, v1 was not a precisely defined protocol and ended up with multiple slightly different dialects.\n  We don’t want any room for different interpretations of v2.\n\n- Make Stratum v2 logically similar to v1 whenever possible so that it’s easier to understand for people who are already familiar with the protocol.\n  V1 is widely used not only in bitcoin mining, but also for mining various altcoins.\n\n- Remove as many issues caused by v1 as possible, based on substantial historical experience with it.\n  - Remove explicit mining subscriptions (mining.subscribe) altogether. It was originally part of a more elaborate protocol and is no longer relevant.\n  - Make extranonce subscription a native part of the protocol, not an extension.\n  - Clean up difficulty controlling, which is really suboptimal v1.\n  - Drop JSON.\n  - Rework [BIP310](https://github.com/bitcoin/bips/blob/master/bip-0310.mediawiki) from scratch.\n\n- Allow different mining jobs on the same connection. \n\n- Avoid introducing any additional risks to pool operators and miners since that would make adoption of v2 very improbable.\n\n- Support version rolling natively.\n  Bitcoin block header contains a version field whose bits (determined by [BIP320](https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki)) can be freely used to extend the hashing space for a miner.\n  It is already a common tech, we want to include it as a first class citizen in the new protocol.\n\n- Support header-only mining (not touching the coinbase transaction) in as many situations as possible.\n  Header-only mining should be easier and faster on mining devices, while also decreasing network traffic.\n\n- Dramatically reduce network traffic as well as client-side and server-side computational intensity, while still being able to send and receive hashing results rapidly for precise hash rate measurement (and therefore more precise mining reward distribution).\n\n- Allow miners to (optionally) choose the transaction set they mine through work declaration on some independent communication channel.\n  At the same time, allow miners to choose how they utilize the available bits in the block header `nVersion` field, including both those bits which are used for mining (e.g. version-rolling AsicBoost) by [BIP320](https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki), and those bits used for [BIP8](https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki)/[BIP9](https://github.com/bitcoin/bips/tree/master/bip-0009) signaling.\n  This mechanism must not interfere with the efficiency or security of the main mining protocol.\n  - Use a separate communication channel for transaction selection so that it does not have a performance impact on the main mining/share communication, as well as can be run in three modes - disabled (i.e.pool does not yet support client work selection, to provide an easier transition from Stratum v1), client-push (to maximally utilize the client’s potential block-receive-latency differences from the pool), and client-declared (for pools worried about the potential of clients generating invalid block templates). The key issue to note is that both the client-push and client-declared approaches essentially function as client-push. The primary distinction between them lies in whether the pool validates the job proposed by the miner or not.\n\n- Put complexity on the pool side rather than the miner side whenever possible.\n  Keep the protocol part to be implemented in embedded devices as small and easy as possible.\n  Mining devices tend to be difficult to update.\n  Any mistake in a firmware can be very costly.\n  Either on miners side (non-functioning firmware) or pool side (necessity to implement various workarounds and hacks to support misbehaving firmware).\n\n- Allow for translation to and from the original protocol on a proxy level (e.g. different downstream devices) without the necessity to reconnect.\n\n- Reduce the stale ratio as much as possible through efficiency improvements.\n\n- Support/allow for `nTime` rolling in hardware in a safe and controlled way.\n\n- Simple support for vendor-specific extensions without polluting the protocol, or complicating pool implementation.\n\n- Optional telemetry data, allowing for easy monitoring of farms, without sacrificing the privacy of miners who wish to remain private.\n\n- Allow aggregation of connections to upstream nodes with an option to aggregate or not aggregate hash rate for target setting on those connections.\n\n- Ensure protocol design allows for devices to implement their own swarm algorithms.\n  Mining devices can dynamically form small groups with an elected master that is responsible for aggregating connections towards upstream endpoint(s), acting as a local proxy.\n  Aggregating connections and running multiple channels across a single TCP connection yields a better ratio of actual payload vs TCP/IP header sizes, as the share submission messages are in the range of 20 bytes.\n  Still, to avoid overly complicating the protocol, automated negotiation of swarm/proxy detection is left to future extensions or vendor-specific messages.\n",
    "html": "<h1>2. Design Goals</h1>\n<p>As there are numerous changes from the original Stratum v1 to v2, it may be helpful to briefly review some high-level design goals before getting into more detailed technical specifications:</p>\n<ul>\n<li>\n<p>Develop a binary protocol with a precise definition.\nDespite its simplicity, v1 was not a precisely defined protocol and ended up with multiple slightly different dialects.\nWe don’t want any room for different interpretations of v2.</p>\n</li>\n<li>\n<p>Make Stratum v2 logically similar to v1 whenever possible so that it’s easier to understand for people who are already familiar with the protocol.\nV1 is widely used not only in bitcoin mining, but also for mining various altcoins.</p>\n</li>\n<li>\n<p>Remove as many issues caused by v1 as possible, based on substantial historical experience with it.</p>\n<ul>\n<li>Remove explicit mining subscriptions (mining.subscribe) altogether. It was originally part of a more elaborate protocol and is no longer relevant.</li>\n<li>Make extranonce subscription a native part of the protocol, not an extension.</li>\n<li>Clean up difficulty controlling, which is really suboptimal v1.</li>\n<li>Drop JSON.</li>\n<li>Rework <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0310.mediawiki\">BIP310</a> from scratch.</li>\n</ul>\n</li>\n<li>\n<p>Allow different mining jobs on the same connection.</p>\n</li>\n<li>\n<p>Avoid introducing any additional risks to pool operators and miners since that would make adoption of v2 very improbable.</p>\n</li>\n<li>\n<p>Support version rolling natively.\nBitcoin block header contains a version field whose bits (determined by <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki\">BIP320</a>) can be freely used to extend the hashing space for a miner.\nIt is already a common tech, we want to include it as a first class citizen in the new protocol.</p>\n</li>\n<li>\n<p>Support header-only mining (not touching the coinbase transaction) in as many situations as possible.\nHeader-only mining should be easier and faster on mining devices, while also decreasing network traffic.</p>\n</li>\n<li>\n<p>Dramatically reduce network traffic as well as client-side and server-side computational intensity, while still being able to send and receive hashing results rapidly for precise hash rate measurement (and therefore more precise mining reward distribution).</p>\n</li>\n<li>\n<p>Allow miners to (optionally) choose the transaction set they mine through work declaration on some independent communication channel.\nAt the same time, allow miners to choose how they utilize the available bits in the block header <code>nVersion</code> field, including both those bits which are used for mining (e.g. version-rolling AsicBoost) by <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki\">BIP320</a>, and those bits used for <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki\">BIP8</a>/<a href=\"https://github.com/bitcoin/bips/tree/master/bip-0009\">BIP9</a> signaling.\nThis mechanism must not interfere with the efficiency or security of the main mining protocol.</p>\n<ul>\n<li>Use a separate communication channel for transaction selection so that it does not have a performance impact on the main mining/share communication, as well as can be run in three modes - disabled (i.e.pool does not yet support client work selection, to provide an easier transition from Stratum v1), client-push (to maximally utilize the client’s potential block-receive-latency differences from the pool), and client-declared (for pools worried about the potential of clients generating invalid block templates). The key issue to note is that both the client-push and client-declared approaches essentially function as client-push. The primary distinction between them lies in whether the pool validates the job proposed by the miner or not.</li>\n</ul>\n</li>\n<li>\n<p>Put complexity on the pool side rather than the miner side whenever possible.\nKeep the protocol part to be implemented in embedded devices as small and easy as possible.\nMining devices tend to be difficult to update.\nAny mistake in a firmware can be very costly.\nEither on miners side (non-functioning firmware) or pool side (necessity to implement various workarounds and hacks to support misbehaving firmware).</p>\n</li>\n<li>\n<p>Allow for translation to and from the original protocol on a proxy level (e.g. different downstream devices) without the necessity to reconnect.</p>\n</li>\n<li>\n<p>Reduce the stale ratio as much as possible through efficiency improvements.</p>\n</li>\n<li>\n<p>Support/allow for <code>nTime</code> rolling in hardware in a safe and controlled way.</p>\n</li>\n<li>\n<p>Simple support for vendor-specific extensions without polluting the protocol, or complicating pool implementation.</p>\n</li>\n<li>\n<p>Optional telemetry data, allowing for easy monitoring of farms, without sacrificing the privacy of miners who wish to remain private.</p>\n</li>\n<li>\n<p>Allow aggregation of connections to upstream nodes with an option to aggregate or not aggregate hash rate for target setting on those connections.</p>\n</li>\n<li>\n<p>Ensure protocol design allows for devices to implement their own swarm algorithms.\nMining devices can dynamically form small groups with an elected master that is responsible for aggregating connections towards upstream endpoint(s), acting as a local proxy.\nAggregating connections and running multiple channels across a single TCP connection yields a better ratio of actual payload vs TCP/IP header sizes, as the share submission messages are in the range of 20 bytes.\nStill, to avoid overly complicating the protocol, automated negotiation of swarm/proxy detection is left to future extensions or vendor-specific messages.</p>\n</li>\n</ul>\n"
  },
  "03-Protocol-Overview": {
    "slug": "03-Protocol-Overview",
    "content": "# 3. Protocol Overview\n\nThere are technically three distinct (sub)protocols needed in order to fully use all of the features proposed in this document:\n\n1. **Mining Protocol**  \n   The main protocol used for mining and the direct successor of Stratum v1.\n   A mining device uses it to communicate with its upstream node, pool, or a proxy.\n   A proxy uses it to communicate with a pool (or another proxy).\n   This protocol needs to be implemented in all scenarios.\n   For cases in which a miner or pool does not support transaction selection, this is the only protocol used.\n\n2. **Job Declaration Protocol**  \n   Used by a miner (a whole mining farm) to declare a block template with a pool.\n   Results of this declaration can be re-used for all mining connections to the pool to reduce computational intensity.\n   In other words, a single declaration can be used by an entire mining farm or even multiple farms with hundreds of thousands of devices, making it far more efficient.\n   This is separate to allow pools to terminate such connections on separate infrastructure from mining protocol connections (i.e. share submissions).\n   Further, such connections have very different concerns from share submissions - work declaration likely requires, at a minimum, some spot-checking of work validity, as well as potentially substantial rate-limiting (without the inherent rate-limiting of share difficulty).\n\n3. **Template Distribution Protocol**  \n   A similarly-framed protocol for getting information about the next block out of Bitcoin Core.\n   Designed to replace `getblocktemplate` with something much more efficient and easy to implement for those implementing other parts of Stratum v2.\n\nMeanwhile, there are five possible roles (types of software/hardware) for communicating with these protocols.\n\n1. **Mining Device**  \n   The actual device computing the hashes. This can be further divided into header-only mining devices and standard mining devices, though most devices will likely support both modes.\n\n2. **Pool Service**  \n   Produces jobs (for those not declaring jobs via the Job Declaration Protocol), validates shares, and ensures blocks found by clients are propagated through the network (though clients which have full block templates MUST also propagate blocks into the Bitcoin P2P network).\n\n3. **Mining Proxy (optional)**  \n   Sits in between Mining Device(s) and Pool Service, aggregating connections for efficiency.\n   May optionally provide additional monitoring, receive work from a Job Declarator and use custom work with a pool, or provide other services for a farm.\n\n4. **Job Declarator (optional)**  \n   It is further divided into a Job Declarator Client and a Job Declarator Server.\n   The Job Declarator Client receives custom block templates from a Template Provider and declares use of them with the Job Declarator Server (which is typically Pool side) using the Job Declaration Protocol.\n\n5. **Template Provider**  \n   Generates custom block templates to be passed to the Job Declarator for eventual mining.\n   This is usually just a Bitcoin Core full node (or possibly some other node implementation).\n\nThe Mining Protocol is used for communication between a Mining Device and Pool Service, Mining Device and Mining Proxy, Mining Proxy and Mining Proxy, or Mining Proxy and Pool Service.\n\nThe Job Declaration Protocol is used for communication between a Job Declarator Client and a Job Declarator Server (which is typically Pool side).\n\nThe Template Distribution Protocol is used for communication either between a Job Declarator Client and a Template Provider or between a Pool Service and Template Provider.\n\n\nOne type of software/hardware can fulfill more than one role (e.g. a Mining Proxy is often both a Mining Proxy and a Job Declarator and may occasionally further contain a Template Provider in the form of a full node on the same device).\n\nEach sub-protocol is based on the same technical principles and requires a connection oriented transport layer, such as TCP.\nIn specific use cases, it may make sense to operate the protocol over a connectionless transport with FEC or local broadcast with retransmission.\nHowever, that is outside of the scope of this document.\nThe minimum requirement of the transport layer is to guarantee ordered delivery of the protocol messages.\n\n## 3.1 Data Types Mapping\n\nMessage definitions use common data types described here for convenience.\nMultibyte data types are always serialized as little-endian.\n\n\n| Data Type | Byte Length                                                                                  | Description                                                                                                                                                                                                                                                                                                                                                      |\n| ------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| BOOL          | 1                                                                                            | Boolean value. Encoded as an unsigned 1-bit integer, True = 1, False = 0 with 7 additional padding bits in the high positions. Recipients MUST NOT interpret bits outside of the least significant bit. Senders MAY set bits outside of the least significant bit to any value without any impact on meaning. This allows future use of other bits as flag bits. |\n| U8            | 1                                                                                            | Unsigned integer, 8-bit                                                                                                                                                                                                                                                                                                                                          |\n| U16           | 2                                                                                            | Unsigned integer, 16-bit, little-endian                                                                                                                                                                                                                                                                                                                          |\n| U24           | 3                                                                                            | Unsigned integer, 24-bit, little-endian (commonly deserialized as a 32-bit little-endian integer with a trailing implicit most-significant 0-byte)                                                                                                                                                                                                               |\n| U32           | 4                                                                                            | Unsigned integer, 32-bit, little-endian                                                                                                                                                                                                                                                                                                                          |\n| U64           | 8                                                                                            | Unsigned integer, 64-bit, little-endian                                                                                                                                                                                                                                                                                                                          |\n| U256          | 32                                                                                           | Unsigned integer, 256-bit, little-endian. Often the raw byte output of SHA-256 interpreted as an unsigned integer.                                                                                                                                                                                                                                               |\n| STR0_255      | 1 + LENGTH                                                                                   | String with 8-bit length prefix L. Unsigned integer, followed by L bytes. Allowed range of length is 0 to 255. The string is not null-terminated.                                                                                                                                                                                                                |\n| B0_32         | 1 + LENGTH                                                                                   | Byte array with 8-bit length prefix L. Unsigned integer, followed by a sequence of L bytes. Allowed range of length is 0 to 32.                                                                                                                                                                                                                                  |\n| B0_255        | 1 + LENGTH                                                                                   | Byte array with 8-bit length prefix L. Unsigned integer, followed by a sequence of L bytes. Allowed range of length is 0 to 255.                                                                                                                                                                                                                                 |\n| B0_64K        | 2 + LENGTH                                                                                   | Byte array with 16-bit length prefix L. Unsigned little-endian integer followed by a sequence of L bytes. Allowed range of length is 0 to 65535.                                                                                                                                                                                                                 |\n| B0_16M        | 3 + LENGTH                                                                                   | Byte array with 24-bit length prefix L. Unsigned integer encoded as U24 above, followed by a sequence of L bytes. Allowed range of length is 0 to 2^24-1.                                                                                                                                                                                                        |\n| BYTES         | LENGTH                                                                                       | Arbitrary sequence of LENGTH bytes. See description for how to calculate LENGTH.                                                                                                                                                                                                                                                                                 |\n| MAC           | 16                                                                                           | Message Authentication Code produced with AE algorithm                                                                                                                                                                                                                                                                                                           |\n| PUBKEY        | 32                                                                                           | X coordinate of Secp256k1 public key (see BIP 340)                                                                                                                                                                                                                                                                                                               |\n| SIGNATURE     | 64                                                                                           | Schnorr signature on Secp256k1 (see BIP 340)                                                                                                                                                                                                                                                                                                                     |\n| SHORT_TX_ID   | 6                                                                                            | SipHash-2-4(TX_ID, k0, k1) where two most significant bytes are dropped from the SipHash output to make it 6 bytes. TX_ID is 32 byte transaction id and k0 and k1 are U64 siphash keys.                                                                                                                                                                          |\n| OPTION[T]     | 1 + (occupied ? size(T) : 0)                                                                 | Alias for SEQ0_1[T]. Identical representation to SEQ0_255 but enforces the maximum size of 1                                                                                                                                                                                                                                                                     |\n| SEQ0_255[T]   | Fixed size T: `1 + LENGTH * size(T) Variable length T: 1 + seq.map(\\|x\\| x.length).sum()`    | 1-byte length L, unsigned integer 8-bits, followed by a sequence of L elements of type T. Allowed range of length is 0 to 255.                                                                                                                                                                                                                                   |\n| SEQ0_64K[T]   | Fixed size T: `2 + LENGTH * size(T)Variable length T: 2 + seq.map(\\|x\\| x.length).sum()`     | 2-byte length L, unsigned little-endian integer 16-bits, followed by a sequence of L elements of type T. Allowed range of length is 0 to 65535.                                                                                                                                                                                                                  |\n \n\n## 3.2 Framing\n\nThe protocol is binary, with fixed message framing.\nEach message begins with the extension type, message type, and message length (six bytes in total), followed by a variable length message.\nThe message framing is outlined below:\n\n| Field Name  | Type | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| -------------- | ----------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| extension_type | U16         | Unique identifier of the extension associated with this protocol message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| msg_type       | U8          | Unique identifier of this protocol message                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| msg_length     | U24         | Length of the protocol message, not including this header                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| payload        | BYTES       | Message-specific payload of length msg_length. If the MSB in extension_type (the channel_msg bit) is set the first four bytes are defined as a U32 \"channel_id\", though this definition is repeated in the message definitions below and these 4 bytes are included in msg_length.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n\n### 3.2.1 Routing Frames over Channels\n\nSome bits of the `extension_type` field can also be repurposed for signaling on how the frame should be handled across channels.\n\nThe least significant bit of `extension_type` (i.e., bit 15, 0-indexed, also known as `channel_msg`) indicates a message which is specific to a channel, whereas if the most significant bit is unset, the message is to be interpreted by the immediate receiving device. \n\nNote that the `channel_msg` bit is ignored in the extension lookup, i.e., an `extension_type` of `0x8ABC` is for the same \"extension\" as `0x0ABC`. \n\nIf the `channel_msg` bit is set, the first four bytes of the payload field is a `U32` representing the `channel_id` this message is destined for (these bytes are repeated in the message framing descriptions below).\n\nNote that for the Job Declaration and Template Distribution Protocols the `channel_msg` bit is always unset.\n\n## 3.3 Reconnecting Downstream Nodes\n\nAn upstream stratum node may occasionally request reconnection of its downstream peers to a different host (e.g. due to maintenance reasons, etc.).\nThis request is per upstream connection and affects all open channels towards the upstream stratum node.\n\nAfter receiving a request to reconnect, the downstream node MUST run the handshake protocol with the new node as long as its previous connection was also running through a secure cryptographic session state.\n\n## 3.4 Protocol Extensions\n\nProtocol extensions may be defined by using a non-0 `extension_type` field in the message header (not including the `channel_msg` bit).\nThe value used MUST either be in the range `0x4000` - `0x7fff` (inclusive, i.e. have the second-to-most-significant-bit set) denoting an \"experimental\" extension and not be present in production equipment, or have been allocated for the purpose at [http://stratumprotocol.org](http://stratumprotocol.org).\nWhile extensions SHOULD have BIPs written describing their full functionality, `extension_type` allocations MAY also be requested for vendor-specific proprietary extensions to be used in production hardware.\nThis is done by sending an email with a brief description of the intended use case to the Bitcoin Protocol Development List and extensions@stratumprotocol.org.\n(Note that these contacts may change in the future, please check the latest version of this BIP prior to sending such a request.)\n\nExtensions are left largely undefined in this BIP, however, there are some basic requirements that all extensions must comply with/be aware of.\nFor unknown `extension_type`'s, the `channel_msg` bit in the `extension_type` field determines which device the message is intended to be processed on: if set, the channel endpoint (i.e. either an end mining device, or a pool server) is the final recipient of the message, whereas if unset, the final recipient is the endpoint of the connection on which the message is sent.\nNote that in cases where channels are aggregated across multiple devices, the proxy which is aggregating multiple devices into one channel forms the channel’s \"endpoint\" and processes channel messages.\nThus, any proxy devices which receive a message with the `channel_msg` bit set and an unknown `extension_type` value MUST forward that message to the downstream/upstream device which corresponds with the `channel_id` specified in the first four bytes of the message payload.\nAny `channel_id` mapping/conversion required for other channel messages MUST be done on the `channel_id` in the first four bytes of the message payload, but the message MUST NOT be otherwise modified.\nIf a device is aware of the semantics of a given extension type, it MUST process messages for that extension in accordance with the specification for that extension.\n\nMessages with an unknown `extension_type` which are to be processed locally (as defined above) MUST be discarded and ignored.\n\nExtensions MUST require version negotiation with the recipient of the message to check that the extension is supported before sending non-version-negotiation messages for it.\nThis prevents the needlessly wasted bandwidth and potentially serious performance degradation of extension messages when the recipient does not support them.\n\nSee `ChannelEndpointChanged` message in Common Protocol Messages for details about how extensions interact with dynamic channel reconfiguration in proxies.\n\n## 3.5 Error Codes\n\nThe protocol uses string error codes.\nThe list of error codes can differ between implementations, and thus implementations MUST NOT take any automated action(s) on the basis of an error code.\nImplementations/pools SHOULD provide documentation on the meaning of error codes and error codes SHOULD use printable ASCII where possible.\nFurthermore, error codes MUST NOT include control characters.\n\nTo make interoperability simpler, the following error codes are provided which implementations SHOULD consider using for the given scenarios.\nIndividual error codes are also specified along with their respective error messages.\n\n- `unknown-user`\n- `too-low-difficulty`\n- `stale-share`\n- `unsupported-feature-flags`\n- `unsupported-protocol`\n- `protocol-version-mismatch`\n\n## 3.6 Common Protocol Messages\n\nThe following protocol messages are common across all of the protocols described in this BIP.\n\n### 3.6.1 `SetupConnection` (Client -> Server)\n\nInitiates the connection.\nThis MUST be the first message sent by the client on the newly opened connection.\nServer MUST respond with either a `SetupConnection.Success` or `SetupConnection.Error` message.\nClients that are not configured to provide telemetry data to the upstream node SHOULD set `device_id` to 0-length strings.\nHowever, they MUST always set vendor to a string describing the manufacturer/developer and firmware version and SHOULD always set `hardware_version` to a string describing, at least, the particular hardware/software package in use.\n\n| Field Name         | Data Type | Description                                                                                                                 |\n|--------------------|-----------|-----------------------------------------------------------------------------------------------------------------------------|\n| protocol           | U8        | 0 = Mining Protocol <br>1 = Job Declaration <br>2 = Template Distribution Protocol                                          |\n| min_version        | U16       | The minimum protocol version the client supports (currently must be 2)                                                      |\n| max_version        | U16       | The maximum protocol version the client supports (currently must be 2)                                                      |\n| flags              | U32       | Flags indicating optional protocol features the client supports. Each protocol from protocol field as its own values/flags. |\n| endpoint_host      | STRO_255  | ASCII text indicating the hostname or IP address                                                                            |\n| endpoint_port      | U16       | Connecting port value                                                                                                       |\n| Device Information |           |                                                                                                                             |\n| vendor             | STR0_255  | E.g. \"Bitmain\"                                                                                                              |\n| hardware_version   | STR0_255  | E.g. \"S9i 13.5\"                                                                                                             |\n| firmware           | STR0_255  | E.g. \"braiins-os-2018-09-22-1-hash\"                                                                                         |\n| device_id          | STR0_255  | Unique identifier of the device as defined by the vendor                                                                    |\n\n\n### 3.6.2 `SetupConnection.Success` (Server -> Client)\n\nResponse to `SetupConnection` message if the server accepts the connection.\nThe client is required to verify the set of feature flags that the server supports and act accordingly.\n\n| Field Name   | Data Type | Description                                                                                                                                             |\n|--------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------|\n| used_version | U16       | Selected version proposed by the connecting node that the upstream node supports. This version will be used on the connection for the rest of its life. |\n| flags        | U32       | Flags indicating optional protocol features the server supports. Each protocol from protocol field has its own values/flags.                            |\n\n### 3.6.3 `SetupConnection.Error` (Server -> Client)\n\nWhen protocol version negotiation fails (or there is another reason why the upstream node cannot setup the connection) the server sends this message with a particular error code prior to closing the connection.\n\nIn order to allow a client to determine the set of available features for a given server (e.g. for proxies which dynamically switch between different pools and need to be aware of supported options), clients SHOULD send a SetupConnection message with all flags set and examine the (potentially) resulting `SetupConnection.Error` message’s flags field.\nThe Server MUST provide the full set of flags which it does not support in each `SetupConnection.Error` message and MUST consistently support the same set of flags across all servers on the same hostname and port number.\nIf flags is 0, the error is a result of some condition aside from unsupported flags.\n\n| Field Name | Data Type | Description                                                 |\n| ---------- | --------- | ----------------------------------------------------------- |\n| flags      | U32       | Flags indicating features causing an error                  |\n| error_code | STR0_255  | Human-readable error code(s), see Error Codes section below |\n\nPossible error codes:\n\n- `unsupported-feature-flags`\n- `unsupported-protocol`\n- `protocol-version-mismatch`\n\n### 3.6.4 `ChannelEndpointChanged` (Server -> Client)\n\nWhen a channel’s upstream or downstream endpoint changes and that channel had previously sent messages with **`channel_msg`** bitset of unknown `extension_type`, the intermediate proxy MUST send a **`ChannelEndpointChanged`** message.\nUpon receipt thereof, any extension state (including version negotiation and the presence of support for a given extension) MUST be reset and version/presence negotiation must begin again.\n\n| Field Name | Data Type | Description                           |\n| ---------- | --------- | ------------------------------------- |\n| channel_id | U32       | The channel which has changed enpoint |\n\n### 3.6.5 `Reconnect` (Server -> Client)\n\nThis message allows clients to be redirected to a new upstream node.\n\n| Field Name | Data Type | Description                                                           |\n| ---------- | --------- | --------------------------------------------------------------------- |\n| new_host   | STR0_255  | When empty, downstream node attempts to reconnect to its present host |\n| new_port   | U16       | When 0, downstream node attempts to reconnect to its present port     |\n\nThis message is connection-related so that it should not be propagated downstream by intermediate proxies.\nUpon receiving the message, the client re-initiates the Noise handshake and uses the pool’s authority public key to verify that the certificate presented by the new server has a valid signature.\n\nFor security reasons, it is not possible to reconnect to a server with a certificate signed by a different pool authority key.\nThe message intentionally does not contain a **pool public key** and thus cannot be used to reconnect to a different pool.\nThis ensures that an attacker will not be able to redirect hashrate to an arbitrary server should the pool server get compromised and instructed to send reconnects to a new location.\n",
    "html": "<h1>3. Protocol Overview</h1>\n<p>There are technically three distinct (sub)protocols needed in order to fully use all of the features proposed in this document:</p>\n<ol>\n<li>\n<p><strong>Mining Protocol</strong><br>\nThe main protocol used for mining and the direct successor of Stratum v1.\nA mining device uses it to communicate with its upstream node, pool, or a proxy.\nA proxy uses it to communicate with a pool (or another proxy).\nThis protocol needs to be implemented in all scenarios.\nFor cases in which a miner or pool does not support transaction selection, this is the only protocol used.</p>\n</li>\n<li>\n<p><strong>Job Declaration Protocol</strong><br>\nUsed by a miner (a whole mining farm) to declare a block template with a pool.\nResults of this declaration can be re-used for all mining connections to the pool to reduce computational intensity.\nIn other words, a single declaration can be used by an entire mining farm or even multiple farms with hundreds of thousands of devices, making it far more efficient.\nThis is separate to allow pools to terminate such connections on separate infrastructure from mining protocol connections (i.e. share submissions).\nFurther, such connections have very different concerns from share submissions - work declaration likely requires, at a minimum, some spot-checking of work validity, as well as potentially substantial rate-limiting (without the inherent rate-limiting of share difficulty).</p>\n</li>\n<li>\n<p><strong>Template Distribution Protocol</strong><br>\nA similarly-framed protocol for getting information about the next block out of Bitcoin Core.\nDesigned to replace <code>getblocktemplate</code> with something much more efficient and easy to implement for those implementing other parts of Stratum v2.</p>\n</li>\n</ol>\n<p>Meanwhile, there are five possible roles (types of software/hardware) for communicating with these protocols.</p>\n<ol>\n<li>\n<p><strong>Mining Device</strong><br>\nThe actual device computing the hashes. This can be further divided into header-only mining devices and standard mining devices, though most devices will likely support both modes.</p>\n</li>\n<li>\n<p><strong>Pool Service</strong><br>\nProduces jobs (for those not declaring jobs via the Job Declaration Protocol), validates shares, and ensures blocks found by clients are propagated through the network (though clients which have full block templates MUST also propagate blocks into the Bitcoin P2P network).</p>\n</li>\n<li>\n<p><strong>Mining Proxy (optional)</strong><br>\nSits in between Mining Device(s) and Pool Service, aggregating connections for efficiency.\nMay optionally provide additional monitoring, receive work from a Job Declarator and use custom work with a pool, or provide other services for a farm.</p>\n</li>\n<li>\n<p><strong>Job Declarator (optional)</strong><br>\nIt is further divided into a Job Declarator Client and a Job Declarator Server.\nThe Job Declarator Client receives custom block templates from a Template Provider and declares use of them with the Job Declarator Server (which is typically Pool side) using the Job Declaration Protocol.</p>\n</li>\n<li>\n<p><strong>Template Provider</strong><br>\nGenerates custom block templates to be passed to the Job Declarator for eventual mining.\nThis is usually just a Bitcoin Core full node (or possibly some other node implementation).</p>\n</li>\n</ol>\n<p>The Mining Protocol is used for communication between a Mining Device and Pool Service, Mining Device and Mining Proxy, Mining Proxy and Mining Proxy, or Mining Proxy and Pool Service.</p>\n<p>The Job Declaration Protocol is used for communication between a Job Declarator Client and a Job Declarator Server (which is typically Pool side).</p>\n<p>The Template Distribution Protocol is used for communication either between a Job Declarator Client and a Template Provider or between a Pool Service and Template Provider.</p>\n<p>One type of software/hardware can fulfill more than one role (e.g. a Mining Proxy is often both a Mining Proxy and a Job Declarator and may occasionally further contain a Template Provider in the form of a full node on the same device).</p>\n<p>Each sub-protocol is based on the same technical principles and requires a connection oriented transport layer, such as TCP.\nIn specific use cases, it may make sense to operate the protocol over a connectionless transport with FEC or local broadcast with retransmission.\nHowever, that is outside of the scope of this document.\nThe minimum requirement of the transport layer is to guarantee ordered delivery of the protocol messages.</p>\n<h2>3.1 Data Types Mapping</h2>\n<p>Message definitions use common data types described here for convenience.\nMultibyte data types are always serialized as little-endian.</p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Byte Length</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BOOL</td>\n<td>1</td>\n<td>Boolean value. Encoded as an unsigned 1-bit integer, True = 1, False = 0 with 7 additional padding bits in the high positions. Recipients MUST NOT interpret bits outside of the least significant bit. Senders MAY set bits outside of the least significant bit to any value without any impact on meaning. This allows future use of other bits as flag bits.</td>\n</tr>\n<tr>\n<td>U8</td>\n<td>1</td>\n<td>Unsigned integer, 8-bit</td>\n</tr>\n<tr>\n<td>U16</td>\n<td>2</td>\n<td>Unsigned integer, 16-bit, little-endian</td>\n</tr>\n<tr>\n<td>U24</td>\n<td>3</td>\n<td>Unsigned integer, 24-bit, little-endian (commonly deserialized as a 32-bit little-endian integer with a trailing implicit most-significant 0-byte)</td>\n</tr>\n<tr>\n<td>U32</td>\n<td>4</td>\n<td>Unsigned integer, 32-bit, little-endian</td>\n</tr>\n<tr>\n<td>U64</td>\n<td>8</td>\n<td>Unsigned integer, 64-bit, little-endian</td>\n</tr>\n<tr>\n<td>U256</td>\n<td>32</td>\n<td>Unsigned integer, 256-bit, little-endian. Often the raw byte output of SHA-256 interpreted as an unsigned integer.</td>\n</tr>\n<tr>\n<td>STR0_255</td>\n<td>1 + LENGTH</td>\n<td>String with 8-bit length prefix L. Unsigned integer, followed by L bytes. Allowed range of length is 0 to 255. The string is not null-terminated.</td>\n</tr>\n<tr>\n<td>B0_32</td>\n<td>1 + LENGTH</td>\n<td>Byte array with 8-bit length prefix L. Unsigned integer, followed by a sequence of L bytes. Allowed range of length is 0 to 32.</td>\n</tr>\n<tr>\n<td>B0_255</td>\n<td>1 + LENGTH</td>\n<td>Byte array with 8-bit length prefix L. Unsigned integer, followed by a sequence of L bytes. Allowed range of length is 0 to 255.</td>\n</tr>\n<tr>\n<td>B0_64K</td>\n<td>2 + LENGTH</td>\n<td>Byte array with 16-bit length prefix L. Unsigned little-endian integer followed by a sequence of L bytes. Allowed range of length is 0 to 65535.</td>\n</tr>\n<tr>\n<td>B0_16M</td>\n<td>3 + LENGTH</td>\n<td>Byte array with 24-bit length prefix L. Unsigned integer encoded as U24 above, followed by a sequence of L bytes. Allowed range of length is 0 to 2^24-1.</td>\n</tr>\n<tr>\n<td>BYTES</td>\n<td>LENGTH</td>\n<td>Arbitrary sequence of LENGTH bytes. See description for how to calculate LENGTH.</td>\n</tr>\n<tr>\n<td>MAC</td>\n<td>16</td>\n<td>Message Authentication Code produced with AE algorithm</td>\n</tr>\n<tr>\n<td>PUBKEY</td>\n<td>32</td>\n<td>X coordinate of Secp256k1 public key (see BIP 340)</td>\n</tr>\n<tr>\n<td>SIGNATURE</td>\n<td>64</td>\n<td>Schnorr signature on Secp256k1 (see BIP 340)</td>\n</tr>\n<tr>\n<td>SHORT_TX_ID</td>\n<td>6</td>\n<td>SipHash-2-4(TX_ID, k0, k1) where two most significant bytes are dropped from the SipHash output to make it 6 bytes. TX_ID is 32 byte transaction id and k0 and k1 are U64 siphash keys.</td>\n</tr>\n<tr>\n<td>OPTION[T]</td>\n<td>1 + (occupied ? size(T) : 0)</td>\n<td>Alias for SEQ0_1[T]. Identical representation to SEQ0_255 but enforces the maximum size of 1</td>\n</tr>\n<tr>\n<td>SEQ0_255[T]</td>\n<td>Fixed size T: <code>1 + LENGTH * size(T) Variable length T: 1 + seq.map(|x| x.length).sum()</code></td>\n<td>1-byte length L, unsigned integer 8-bits, followed by a sequence of L elements of type T. Allowed range of length is 0 to 255.</td>\n</tr>\n<tr>\n<td>SEQ0_64K[T]</td>\n<td>Fixed size T: <code>2 + LENGTH * size(T)Variable length T: 2 + seq.map(|x| x.length).sum()</code></td>\n<td>2-byte length L, unsigned little-endian integer 16-bits, followed by a sequence of L elements of type T. Allowed range of length is 0 to 65535.</td>\n</tr>\n</tbody>\n</table>\n<h2>3.2 Framing</h2>\n<p>The protocol is binary, with fixed message framing.\nEach message begins with the extension type, message type, and message length (six bytes in total), followed by a variable length message.\nThe message framing is outlined below:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>extension_type</td>\n<td>U16</td>\n<td>Unique identifier of the extension associated with this protocol message</td>\n</tr>\n<tr>\n<td>msg_type</td>\n<td>U8</td>\n<td>Unique identifier of this protocol message</td>\n</tr>\n<tr>\n<td>msg_length</td>\n<td>U24</td>\n<td>Length of the protocol message, not including this header</td>\n</tr>\n<tr>\n<td>payload</td>\n<td>BYTES</td>\n<td>Message-specific payload of length msg_length. If the MSB in extension_type (the channel_msg bit) is set the first four bytes are defined as a U32 “channel_id”, though this definition is repeated in the message definitions below and these 4 bytes are included in msg_length.</td>\n</tr>\n</tbody>\n</table>\n<h3>3.2.1 Routing Frames over Channels</h3>\n<p>Some bits of the <code>extension_type</code> field can also be repurposed for signaling on how the frame should be handled across channels.</p>\n<p>The least significant bit of <code>extension_type</code> (i.e., bit 15, 0-indexed, also known as <code>channel_msg</code>) indicates a message which is specific to a channel, whereas if the most significant bit is unset, the message is to be interpreted by the immediate receiving device.</p>\n<p>Note that the <code>channel_msg</code> bit is ignored in the extension lookup, i.e., an <code>extension_type</code> of <code>0x8ABC</code> is for the same “extension” as <code>0x0ABC</code>.</p>\n<p>If the <code>channel_msg</code> bit is set, the first four bytes of the payload field is a <code>U32</code> representing the <code>channel_id</code> this message is destined for (these bytes are repeated in the message framing descriptions below).</p>\n<p>Note that for the Job Declaration and Template Distribution Protocols the <code>channel_msg</code> bit is always unset.</p>\n<h2>3.3 Reconnecting Downstream Nodes</h2>\n<p>An upstream stratum node may occasionally request reconnection of its downstream peers to a different host (e.g. due to maintenance reasons, etc.).\nThis request is per upstream connection and affects all open channels towards the upstream stratum node.</p>\n<p>After receiving a request to reconnect, the downstream node MUST run the handshake protocol with the new node as long as its previous connection was also running through a secure cryptographic session state.</p>\n<h2>3.4 Protocol Extensions</h2>\n<p>Protocol extensions may be defined by using a non-0 <code>extension_type</code> field in the message header (not including the <code>channel_msg</code> bit).\nThe value used MUST either be in the range <code>0x4000</code> - <code>0x7fff</code> (inclusive, i.e. have the second-to-most-significant-bit set) denoting an “experimental” extension and not be present in production equipment, or have been allocated for the purpose at <a href=\"http://stratumprotocol.org\">http://stratumprotocol.org</a>.\nWhile extensions SHOULD have BIPs written describing their full functionality, <code>extension_type</code> allocations MAY also be requested for vendor-specific proprietary extensions to be used in production hardware.\nThis is done by sending an email with a brief description of the intended use case to the Bitcoin Protocol Development List and <a href=\"mailto:extensions@stratumprotocol.org\">extensions@stratumprotocol.org</a>.\n(Note that these contacts may change in the future, please check the latest version of this BIP prior to sending such a request.)</p>\n<p>Extensions are left largely undefined in this BIP, however, there are some basic requirements that all extensions must comply with/be aware of.\nFor unknown <code>extension_type</code>’s, the <code>channel_msg</code> bit in the <code>extension_type</code> field determines which device the message is intended to be processed on: if set, the channel endpoint (i.e. either an end mining device, or a pool server) is the final recipient of the message, whereas if unset, the final recipient is the endpoint of the connection on which the message is sent.\nNote that in cases where channels are aggregated across multiple devices, the proxy which is aggregating multiple devices into one channel forms the channel’s “endpoint” and processes channel messages.\nThus, any proxy devices which receive a message with the <code>channel_msg</code> bit set and an unknown <code>extension_type</code> value MUST forward that message to the downstream/upstream device which corresponds with the <code>channel_id</code> specified in the first four bytes of the message payload.\nAny <code>channel_id</code> mapping/conversion required for other channel messages MUST be done on the <code>channel_id</code> in the first four bytes of the message payload, but the message MUST NOT be otherwise modified.\nIf a device is aware of the semantics of a given extension type, it MUST process messages for that extension in accordance with the specification for that extension.</p>\n<p>Messages with an unknown <code>extension_type</code> which are to be processed locally (as defined above) MUST be discarded and ignored.</p>\n<p>Extensions MUST require version negotiation with the recipient of the message to check that the extension is supported before sending non-version-negotiation messages for it.\nThis prevents the needlessly wasted bandwidth and potentially serious performance degradation of extension messages when the recipient does not support them.</p>\n<p>See <code>ChannelEndpointChanged</code> message in Common Protocol Messages for details about how extensions interact with dynamic channel reconfiguration in proxies.</p>\n<h2>3.5 Error Codes</h2>\n<p>The protocol uses string error codes.\nThe list of error codes can differ between implementations, and thus implementations MUST NOT take any automated action(s) on the basis of an error code.\nImplementations/pools SHOULD provide documentation on the meaning of error codes and error codes SHOULD use printable ASCII where possible.\nFurthermore, error codes MUST NOT include control characters.</p>\n<p>To make interoperability simpler, the following error codes are provided which implementations SHOULD consider using for the given scenarios.\nIndividual error codes are also specified along with their respective error messages.</p>\n<ul>\n<li><code>unknown-user</code></li>\n<li><code>too-low-difficulty</code></li>\n<li><code>stale-share</code></li>\n<li><code>unsupported-feature-flags</code></li>\n<li><code>unsupported-protocol</code></li>\n<li><code>protocol-version-mismatch</code></li>\n</ul>\n<h2>3.6 Common Protocol Messages</h2>\n<p>The following protocol messages are common across all of the protocols described in this BIP.</p>\n<h3>3.6.1 <code>SetupConnection</code> (Client -&gt; Server)</h3>\n<p>Initiates the connection.\nThis MUST be the first message sent by the client on the newly opened connection.\nServer MUST respond with either a <code>SetupConnection.Success</code> or <code>SetupConnection.Error</code> message.\nClients that are not configured to provide telemetry data to the upstream node SHOULD set <code>device_id</code> to 0-length strings.\nHowever, they MUST always set vendor to a string describing the manufacturer/developer and firmware version and SHOULD always set <code>hardware_version</code> to a string describing, at least, the particular hardware/software package in use.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protocol</td>\n<td>U8</td>\n<td>0 = Mining Protocol <br>1 = Job Declaration <br>2 = Template Distribution Protocol</td>\n</tr>\n<tr>\n<td>min_version</td>\n<td>U16</td>\n<td>The minimum protocol version the client supports (currently must be 2)</td>\n</tr>\n<tr>\n<td>max_version</td>\n<td>U16</td>\n<td>The maximum protocol version the client supports (currently must be 2)</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>U32</td>\n<td>Flags indicating optional protocol features the client supports. Each protocol from protocol field as its own values/flags.</td>\n</tr>\n<tr>\n<td>endpoint_host</td>\n<td>STRO_255</td>\n<td>ASCII text indicating the hostname or IP address</td>\n</tr>\n<tr>\n<td>endpoint_port</td>\n<td>U16</td>\n<td>Connecting port value</td>\n</tr>\n<tr>\n<td>Device Information</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>vendor</td>\n<td>STR0_255</td>\n<td>E.g. “Bitmain”</td>\n</tr>\n<tr>\n<td>hardware_version</td>\n<td>STR0_255</td>\n<td>E.g. “S9i 13.5”</td>\n</tr>\n<tr>\n<td>firmware</td>\n<td>STR0_255</td>\n<td>E.g. “braiins-os-2018-09-22-1-hash”</td>\n</tr>\n<tr>\n<td>device_id</td>\n<td>STR0_255</td>\n<td>Unique identifier of the device as defined by the vendor</td>\n</tr>\n</tbody>\n</table>\n<h3>3.6.2 <code>SetupConnection.Success</code> (Server -&gt; Client)</h3>\n<p>Response to <code>SetupConnection</code> message if the server accepts the connection.\nThe client is required to verify the set of feature flags that the server supports and act accordingly.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>used_version</td>\n<td>U16</td>\n<td>Selected version proposed by the connecting node that the upstream node supports. This version will be used on the connection for the rest of its life.</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>U32</td>\n<td>Flags indicating optional protocol features the server supports. Each protocol from protocol field has its own values/flags.</td>\n</tr>\n</tbody>\n</table>\n<h3>3.6.3 <code>SetupConnection.Error</code> (Server -&gt; Client)</h3>\n<p>When protocol version negotiation fails (or there is another reason why the upstream node cannot setup the connection) the server sends this message with a particular error code prior to closing the connection.</p>\n<p>In order to allow a client to determine the set of available features for a given server (e.g. for proxies which dynamically switch between different pools and need to be aware of supported options), clients SHOULD send a SetupConnection message with all flags set and examine the (potentially) resulting <code>SetupConnection.Error</code> message’s flags field.\nThe Server MUST provide the full set of flags which it does not support in each <code>SetupConnection.Error</code> message and MUST consistently support the same set of flags across all servers on the same hostname and port number.\nIf flags is 0, the error is a result of some condition aside from unsupported flags.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flags</td>\n<td>U32</td>\n<td>Flags indicating features causing an error</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Human-readable error code(s), see Error Codes section below</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>unsupported-feature-flags</code></li>\n<li><code>unsupported-protocol</code></li>\n<li><code>protocol-version-mismatch</code></li>\n</ul>\n<h3>3.6.4 <code>ChannelEndpointChanged</code> (Server -&gt; Client)</h3>\n<p>When a channel’s upstream or downstream endpoint changes and that channel had previously sent messages with <strong><code>channel_msg</code></strong> bitset of unknown <code>extension_type</code>, the intermediate proxy MUST send a <strong><code>ChannelEndpointChanged</code></strong> message.\nUpon receipt thereof, any extension state (including version negotiation and the presence of support for a given extension) MUST be reset and version/presence negotiation must begin again.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>The channel which has changed enpoint</td>\n</tr>\n</tbody>\n</table>\n<h3>3.6.5 <code>Reconnect</code> (Server -&gt; Client)</h3>\n<p>This message allows clients to be redirected to a new upstream node.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>new_host</td>\n<td>STR0_255</td>\n<td>When empty, downstream node attempts to reconnect to its present host</td>\n</tr>\n<tr>\n<td>new_port</td>\n<td>U16</td>\n<td>When 0, downstream node attempts to reconnect to its present port</td>\n</tr>\n</tbody>\n</table>\n<p>This message is connection-related so that it should not be propagated downstream by intermediate proxies.\nUpon receiving the message, the client re-initiates the Noise handshake and uses the pool’s authority public key to verify that the certificate presented by the new server has a valid signature.</p>\n<p>For security reasons, it is not possible to reconnect to a server with a certificate signed by a different pool authority key.\nThe message intentionally does not contain a <strong>pool public key</strong> and thus cannot be used to reconnect to a different pool.\nThis ensures that an attacker will not be able to redirect hashrate to an arbitrary server should the pool server get compromised and instructed to send reconnects to a new location.</p>\n"
  },
  "04-Protocol-Security": {
    "slug": "04-Protocol-Security",
    "content": "# 4 Protocol Security\n\nStratum V2 employs a type of encryption scheme called AEAD (authenticated encryption with associated data) to address the security aspects of all communication that occurs between clients and servers.\nThis provides both confidentiality and integrity for the ciphertexts (i.e. encrypted data) being transferred, as well as providing integrity for associated data which is not encrypted.\nPrior to opening any Stratum V2 channels for mining, clients MUST first initiate the cryptographic session state that is used to encrypt all messages sent between themselves and servers.\nThus, the cryptographic session state is independent of V2 messaging conventions.\n\nAt the same time, this specification proposes optional use of a particular handshake protocol based on the **[Noise Protocol framework](https://noiseprotocol.org/noise.html)**.\nThe client and server establish secure communication using Diffie-Hellman (DH) key agreement, as described in greater detail in the Authenticated Key Agreement Handshake section below.\n\nUsing the handshake protocol to establish secured communication is **optional** on the local network (e.g. local mining devices talking to a local mining proxy).\nHowever, it is **mandatory** for remote access to the upstream nodes, whether they be pool mining services, job declarating services or template distributors.\n\n## 4.1 Motivation for Authenticated Encryption with Associated Data\n\nData transferred by the mining protocol MUST not provide adversary information that they can use to estimate the performance of any particular miner. Any intelligence about submitted shares can be directly converted to estimations of a miner’s earnings and can be associated with a particular username. This is unacceptable privacy leakage that needs to be addressed.\n\n## 4.2 Motivation for Using the Noise Protocol Framework\n\nThe reasons why Noise Protocol Framework has been chosen are listed below:\n\n- The Framework provides a formalism to describe the handshake protocol that can be verified.\n- A custom certificate scheme is now possible (no need to use x509 certificates).\n\n## 4.3 Choice of cryptographic primitives\n\nNoise encrypted session requires Elliptic Curve (EC), Hash function (`HASH()`) and cipher function that supports AEAD mode<sup>[1](#reference-1)</sup>.\n\nThis specification describes mandatory cryptographic primitives that each implementation needs to support.\nThese primitives are chosen so that Noise Encryption layer for Stratum V2 can be implemented using primitives already present in Bitcoin Core project at the time of writing this spec.\n\n### 4.3.1 Elliptic Curve\n\n- Bitcoin's secp256k1 curve<sup>[2](#reference-2)</sup> is used\n- Schnorr signature scheme is used as described in BIP340<sup>[3](#reference-3)</sup>\n\n#### 4.3.1.1 EC point encoding remarks\n\nSecp256k1 curve points, i.e. Public Keys, are points with of X- and Y-coordinate.\nWe serialize them in three different ways, only using the x-coordinate.\n\n1. When signing or verifying a certificate, we use the 32 byte x-only\nencoding as defined in BIP 340.<sup>[3](#reference-3)</sup>.\n\n2. When sharing keys during the handshake, whether in plain text or encrypted,\nwe use the 64 byte ElligatorSwift x-only encoding as defined in BIP324<sup>[7](#reference-7)</sup> under \"ElligatorSwift encoding of curve X coordinates\". This encoding uses 64-bytes instead of 32-bytes in order to produce a\npseudo-random bytesteam. This is useful because the protocol handshake starts with\neach side sending their public key in plain text. Additionally the use of X-only\nElligatorSwift ECDH removes the need to grind or negate private keys.\n\n3. The Authority public key is base58-check encoded as described in 4.7.\n\nDigital signatures are serialized in 64-bytes like in BIP340<sup>[3](#reference-3)</sup>.\n\nKey generation algorithm:\n\n1. generate random 32-byte secret key `sk`\n2. let `d' = int(sk)`\n3. fail if `d = 0` or `d' > n` where `n` is group order of secp256k1 curve\n4. compute `P` as `d'⋅G`\n5. drop the Y coordinate and compute (u, t) = XElligatorSwift(P.x)\n6. ellswift_pub = bytes(u) || bytes(t)\n7. output keypair `(sk, ellswift_pub)`\n\nTo perform X-only ECDH we use ellswift_ecdh_xonly(ellswift_theirs, d) as described in BIP324<sup>[7](#reference-7)</sup> under \"Shared secret computation\". The result is 32 bytes.\n\nNo assumption is made about the parity of Y-coordinate. For the purpose of signing\n(e.g. certificate) and ECDH (handshake) it is _not_ necessary to \"grind\"\nthe private key. The choosen algoritms take care of this by implicitly negatating\nthe key, as if its public key had an even Y-coordinate.\n\nFor more information refer to BIP340<sup>[3](#reference-3)</sup> and BIP324<sup>[7](#reference-7)</sup>.\n\n### 4.3.2 Hash function\n\n- `SHA-256()` is used as a `HASH()`\n\n### 4.3.3 Cipher function for authenticated encryption\n\n- Cipher has methods for encryption and decryption for key `k`, nonce `n`, associated_data `ad`, plaintext `pt` and ciphertext `ct`\n  - `ENCRYPT(k, n, ad, pt)`\n  - `DECRYPT(k, n, ad, ct)`\n- ChaCha20 and Poly1305 in AEAD mode<sup>[4](#reference-4)</sup> (ChaChaPoly) is used as a default AEAD cipher\n\n## 4.4 Cryptographic operations\n\n### 4.4.1 CipherState object\n\nObject that encapsulates encryption and decryption operations with underlying AEAD mode cipher functions using 32-byte encryption key `k` and 8-byte nonce `n`.\nCipherState has the following interface:\n\n- `InitializeKey(key)`:\n  - Sets `k = key`, `n = 0`\n- `EncryptWithAd(ad, plaintext)`\n  - If `k` is non-empty, performs `ENCRYPT(k, n++, ad, plaintext)` on the underlying cipher function, otherwise returns `plaintext`. The `++` post-increment operator applied to `n` means: \"use the current n value, then increment it\".\n  - Where `ENCRYPT` is an evaluation of `ChaCha20-Poly1305` (IETF variant) with the passed arguments, with nonce `n` encoded as 32 zero bits, followed by a _little-endian_ 64-bit value. Note: this follows the Noise Protocol convention, rather than our normal endian.\n- `DecryptWithAd(ad, ciphertext)`\n  - If `k` is non-empty performs `DECRYPT(k, n++, ad, plaintext)` on the underlying cipher function, otherwise returns ciphertext. If an authentication failure occurs in `DECRYPT()` then `n` is not incremented and an error is signaled to the caller.\n  - Where `DECRYPT` is an evaluation of `ChaCha20-Poly1305` (IETF variant) with the passed arguments, with nonce `n` encoded as 32 zero bits, followed by a _little-endian_ 64-bit value.\n\n### 4.4.2 Handshake Operation\n\nThroughout the handshake process, each side maintains these variables:\n\n- `ck`: **chaining key**. Accumulated hash of all previous ECDH outputs. At the end of the handshake `ck` is used to derive encryption key `k`.\n- `h`: **handshake hash**. Accumulated hash of _all_ handshake data that has been sent and received so far during the handshake process\n- `e`, `re` **ephemeral keys**. Ephemeral key and remote party's ephemeral key, respectively.\n- `s`, `rs` **static keys**. Static key and remote party's static key, respectively.\n\nThe following functions will also be referenced:\n\n- `generateKey()`: generates and returns a fresh `secp256k1` keypair\n\n  - Where the object returned by `generateKey` has two attributes:\n    - `.public_key`, which returns an abstract object representing the public key\n    - `.private_key`, which represents the private key used to generate the public key\n  - Where the public_key object also has a single method:\n    - `.serializeEllSwift()` that outputs a 64-byte EllSwift encoded serialization of the X-coordinate of EC point (the Y-coordinate is ignored)\n\n- `a || b` denotes the concatenation of two byte strings `a` and `b`\n\n- `HMAC-HASH(key, data)`\n\n  - Applies HMAC defined in `RFC 2104`<sup>[5](#reference-5)</sup>\n  - In our case where the key is always 32 bytes, this reduces down to:\n    - pad the key with zero bytes to fill the hash block (block length is 64 bytes in case of SHA-256): `k' = k || <zero-bytes>`\n    - calculate `temp = SHA-256((k' XOR ipad) || data)` where ipad is repeated 0x36 byte\n    - output `SHA-256((k' XOR opad) || temp)` where opad is repeated 0x5c byte\n\n- `HKDF(chaining_key, input_key_material)`: a function defined in `RFC 5869`<sup>[6](#reference-6)</sup>, evaluated with a zero-length `info` field and 2 `num_output` field:\n\n  - Sets `temp_key = HMAC-HASH(chaining_key, input_key_material)`\n  - Sets `output1 = HMAC-HASH(temp_key, byte(0x01))`\n  - Sets `output2 = HMAC-HASH(temp_key, output1 || byte(0x02))`\n  - Returns the pair `(output1, output2)`\n\n- `MixKey(input_key_material)`: Executes the following steps:\n\n  - sets `(ck, temp_k) = HKDF(ck, input_key_material, 2)`\n  - calls `InitializeKey(temp_k)`\n\n- `MixHash(data)`: Sets `h = HASH(h || data)`\n\n- `EncryptAndHash(plaintext)`:\n\n  - If `k` is non-empty sets `ciphertext = EncryptWithAd(h, plaintext)`, otherwise `ciphertext = plaintext`\n  - Calls `MixHash(ciphertext)`\n  - returns `ciphertext`\n\n- `DecryptAndHash(ciphertext)`:\n\n  - If `k` is non-empty sets `plaintext = DecryptWithAd(h, ciphertext)`, otherwise `plaintext = ciphertext`\n  - Calls `MixHash(ciphertext)`\n  - returns `plaintext`\n\n- `ECDH(k, rk)`: performs an Elliptic-Curve Diffie-Hellman operation\n  using `k`, which is a   valid `secp256k1` private key, and `rk`, which is a EllSwift\n  encoded public key\n  - The output is 32 bytes\n  - It is a shortcut for performing operation `v2_ecdh` defined in BIP324<sup>[7](#reference-7)</sup>:\n    - let `k, ellswift_k` be key pair created by `ellswift_create()` function\n    - let `rk` be remote public key **encoded as ellswift**.\n    - let `initiator` be bool flag that is **true** if the party performing ECDH initiated the handshake\n    - then `ECDH(k, rk) = v2_ecdh(k, ellswift_k, rk, initiator)`\n\n- `v2_ecdh(k, ellswift_k, rk, initiator)`: \n  - let `ecdh_point_x32` = `ellswift_ecdh_xonly(rk, k)`\n  - if initiator == true:\n    - return `tagged_hash(ellswift_k, rk, ecdh_point_x32)`\n    - else return `tagged_hash(rk, ellswift_k, ecdh_point_x32)`\n  - **Note that the ecdh result is not commutative with respect to roles! Therefore the initiator flag is needed**\n\n- `ellswift_ecdh_xonly` - see BIP324<sup>[7](#reference-7)</sup>\n- `tagged_hash(a, b, c)`:\n  - let tag = `SHA256(\"bip324_ellswift_xonly_ecdh\")`\n  - return `SHA256(concatenate(tag, tag, a, b, c))`\n\n\n\n\n## 4.5 Authenticated Key Agreement Handshake\n\nThe handshake chosen for the authenticated key exchange is an **`Noise_NX`** augmented by server authentication with simple 2 level public key infrastructure.\n\nThe complete authenticated key agreement (`Noise NX`) is performed in three distinct steps (acts).\n\n1. NX-handshake part 1: `-> e`\n2. NX-handshake part 2: `<- e, ee, s, es, SIGNATURE_NOISE_MESSAGE`\n3. Server authentication: Initiator validates authenticity of server using from `SIGNATURE_NOISE_MESSAGE`\n\nShould the decryption (i.e. authentication code validation) fail at any point, the session must be terminated.\n\n### 4.5.1 Handshake Act 1: NX-handshake part 1 `-> e`\n\nPrior to starting first round of NX-handshake, both initiator and responder initializes handshake variables `h` (hash output), `ck` (chaining key) and `k` (encryption key):\n\n1. **hash output** `h = HASH(protocolName)`\n\n- Since `protocolName` more than 32 bytes in length, apply `HASH` to it.\n- `protocolName` is official noise protocol name: `Noise_NX_Secp256k1+EllSwift_ChaChaPoly_SHA256`\n  encoded as an ASCII string\n\n2. **chaining key** `ck = h`\n3. **hash output** `h = HASH(h)`\n4. **encryption key** `k ` empty\n\n#### 4.5.1.1 Initiator\n\nInitiator generates ephemeral keypair and sends the public key to the responder:\n\n1. initializes empty output buffer\n2. generates ephemeral keypair `e`, appends `e.public_key.serializeEllSwift()` to the buffer (64 bytes plaintext EllSwift encoded public key)\n3. calls `MixHash(e.public_key)`\n4. calls `EncryptAndHash()` with empty payload and appends the ciphertext to the buffer (note that _k_ is empty at this point, so this effectively reduces down to `MixHash()` on empty data)\n5. submits the buffer for sending to the responder in the following format\n\n##### Ephemeral public key message:\n\n| Field name | Description                      |\n| ---------- | -------------------------------- |\n| PUBKEY     | Initiator's ephemeral public key |\n\nMessage length: 64 bytes\n\n#### 4.5.1.2 Responder\n\n1. receives ephemeral public key message (64 bytes plaintext EllSwift encoded public key)\n2. parses received public key as `re.public_key`\n3. calls `MixHash(re.public_key)`\n4. calls `DecryptAndHash()` on remaining bytes (i.e. on empty data with empty _k_, thus effectively only calls `MixHash()` on empty data)\n\n### 4.5.2 Handshake Act 2: NX-handshake part 2 `<- e, ee, s, es, SIGNATURE_NOISE_MESSAGE`\n\nResponder provides its ephemeral, encrypted static public keys and encrypted `SIGNATURE_NOISE_MESSAGE` to the initiator, performs Elliptic-Curve Diffie-Hellman operations.\n\n##### SIGNATURE_NOISE_MESSAGE\n\n| Field Name      | Data Type | Description                                                    |\n| --------------- | --------- | -------------------------------------------------------------- |\n| version         | U16       | Version of the certificate format                              |\n| valid_from      | U32       | Validity start time (unix timestamp)                           |\n| not_valid_after | U32       | Signature is invalid after this point in time (unix timestamp) |\n| signature       | SIGNATURE | Certificate signature                                          |\n\nLength: 74 bytes\n\n#### 4.5.2.1 Responder\n\n1. initializes empty output buffer\n2. generates ephemeral keypair `e`, appends `e.public_key` to the buffer (64 bytes plaintext EllSwift encoded public key)\n3. calls `MixHash(e.public_key)`\n4. calls `MixKey(ECDH(e.private_key, re.public_key))`\n5. appends `EncryptAndHash(s.public_key)` (64 bytes encrypted EllSwift encoded public key, 16 bytes MAC)\n6. calls `MixKey(ECDH(s.private_key, re.public_key))`\n7. appends `EncryptAndHash(SIGNATURE_NOISE_MESSAGE)` to the buffer\n8. submits the buffer for sending to the initiator\n9. return pair of CipherState objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction:\n   1. sets `temp_k1, temp_k2 = HKDF(ck, zerolen, 2)`\n   2. creates two new CipherState objects `c1` and `c2`\n   3. calls `c1.InitializeKey(temp_k1)` and `c2.InitializeKey(temp_k2)`\n   4. returns the pair `(c1, c2)`\n\n##### Message format of NX-handshake part 2\n\n| Field name              | Description                                                                                                                                                    |\n| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| PUBKEY                  | Responder's plaintext ephemeral public key                                                                                                                     |\n| PUBKEY                  | Responder's encrypted static public key                                                                                                                        |\n| MAC                     | Message authentication code for responder's static public key                                                                                                  |\n| SIGNATURE_NOISE_MESSAGE | Signed message containing Responder's static key. Signature is issued by authority that is generally known to operate the server acting as the noise responder |\n| MAC                     | Message authentication code for SIGNATURE_NOISE_MESSAGE                                                                                                        |\n\nMessage length: 170 bytes\n\n#### 4.5.2.2 Initiator\n\n1. receives NX-handshake part 2 message\n2. interprets first 64 bytes as EllSwift encoded `re.public_key`\n3. calls `MixHash(re.public_key)`\n4. calls `MixKey(ECDH(e.private_key, re.public_key))`\n5. decrypts next 80 bytes with `DecryptAndHash()` and stores the results as `rs.public_key` which is **server's static public key** (note that 64 bytes is the public key and 16 bytes is MAC)\n6. calls `MixKey(ECDH(e.private_key, rs.public_key)`\n7. decrypts next 90 bytes with `DecryptAndHash()` and deserialize plaintext into `SIGNATURE_NOISE_MESSAGE` (74 bytes data + 16 bytes MAC)\n8. return pair of CipherState objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction:\n   1. sets `temp_k1, temp_k2 = HKDF(ck, zerolen, 2)`\n   2. creates two new CipherState objects `c1` and `c2`\n   3. calls `c1.InitializeKey(temp_k1)` and `c2.InitializeKey(temp_k2)`\n   4. returns the pair `(c1, c2)`\n\n### 4.5.3 Server authentication\n\nDuring the handshake, initiator receives `SIGNATURE_NOISE_MESSAGE` and **server's static public key**. These parts make up a `CERTIFICATE` signed by an authority whose public key is generally known (for example from pool's website). Initiator confirms the identity of the server by verifying the signature in the certificate.\n\n##### CERTIFICATE\n\n| Field Name           | Data Type | Description                                                    | Signed field |\n| -------------------- | --------- | -------------------------------------------------------------- | ------------ |\n| version              | U16       | Version of the certificate format                              | YES          |\n| valid_from           | U32       | Validity start time (unix timestamp)                           | YES          |\n| not_valid_after      | U32       | Signature is invalid after this point in time (unix timestamp) | YES          |\n| server_public_key    | PUBKEY    | Server's static public key that was used during NX handshake   | YES          |\n| authority_public_key | PUBKEY    | Certificate authority's public key that signed this message    | NO           |\n| signature            | SIGNATURE | Signature over the serialized fields marked for signing        | NO           |\n\nThis message is not sent directly. Instead, it is constructed from SIGNATURE_NOISE_MESSAGE and server's static public\nkey that are sent during the handshake process\n\nThe PUBKEY fields are encoded using only their 32 byte x-coordinate and _not_ with\nEllSwift. For the purpose of generating and verifying the certificate, the 64 byte\nEllSwift encoded server_public_key can be decoded to its 32 byte x-coordinate.\n\n#### 4.5.3.1 Signature structure\n\nSchnorr signature with _key prefixing_ is used<sup>[3](#reference-3)</sup>\n\nsignature is constructed for\n\n- message `m`, where `m` is `HASH` of the serialized fields of the `CERTIFICATE` that are marked for signing, i.e. `m = SHA-256(version || valid_from || not_valid_after || server_public_key)`\n- public key `P` that is Certificate Authority\n\nSignature itself is concatenation of an EC point `R` and an integer `s` (note that each item is serialized as 32 bytes array) for which identity `s⋅G = R + HASH(R || P || m)⋅P` holds.\n\n## 4.6 Encrypted stratum message framing\n\nAfter handshake process is finished, both initiator and responder have CipherState objects for encryption and decryption and after initiator validated server's identity, any subsequent traffic is encrypted and decrypted with `EncryptWithAd()` and `DecryptWithAd()` methods of the respective CipherState objects with zero-length associated data.\n\nMaximum transport message length (ciphertext) is for noise protocol message 65535 bytes.\n\nSince Stratum Message Frame consists of\n- fixed length message header: 6 bytes\n- variable length serialized stratum message\n\nStratum Message header and stratum message payload are processed separately.\n\n#### Encrypting stratum message\n1. serialize stratum message into a plaintext binary string (payload)\n2. prepare the frame header for the Stratum message `message_length` is the length of the plaintext payload.\n3. encrypt and concatenate serialized header and payload:\n   4. `EncryptWithAd([], header)` - 22 bytes\n   5. `EncryptWithAd([], payload)` - variable length encrypted message\n4. concatenate resulting header and payload ciphertext\n\n- Note: The `message_length` (payload_length) in the encrypted Stratum message header always reflects the plaintext payload size. The size of the encrypted payload is implicitly understood to be message_length + MAC size for each block. This simplifies the decryption process and ensures clarity in interpreting frame data.\n\n#### Decrypting stratum message\n1. read exactly 22 bytes and decrypt into stratum frame or fail\n2.The value `frame.message_length` should first be converted to the ciphertext length, and then that amount of data should be read and decrypted into plaintext payload. If decryption fails, the process stops\n3. deserialize plaintext payload into stratum message given by `frame.extension_type` and `frame.message_type` or fail\n\n\n*converting plaintext length to ciphertext length:\n```c\n#define MAX_CT_LEN 65535\n#define MAC_LEN 16\n#define MAX_PT_LEN (MAX_CT_LEN - MAC_LEN)\n\nuint pt_len_to_ct_len(uint pt_len) {\n        uint remainder;\n        remainder = pt_len % MAX_PT_LEN;\n        if (remainder > 0) {\n                remainder += MAC_LEN;\n        }\n        return pt_len / MAX_PT_LEN * MAX_CT_LEN + remainder;\n}\n```\n\n\n#### Encrypted stratum message frame layout\n```\n+--------------------------------------------------+-------------------------------------------------------------------+\n| Extended noise header                            | Encrypted stratum-message payload                                 |\n+--------------------------------------------------+-------------------+-------------------+---------------------------+\n| Header AEAD ciphertext                           | Noise block 1     | Noise block 2     | Last Noise block          |\n| 22 Bytes                                         | 65535 Bytes       | 65535 Bytes       | 17 - 65535 Bytes          |\n+----------------------------------------+---------+-----------+-------+-----------+-------+---------------+-----------+\n| Encrypted Stratum message Header       | MAC     | ct_pld_1  | MAC_1 | ct_pld_2  | MAC_2 | ct_pld_rest   | MAC_rest  |\n| 6 Bytes                                | 16 B    | 65519 B   | 16 B  | 65519 B   | 16 B  | 1 - 65519 B   | 16 Bytes  |\n+================+==========+============+=========+===========+=======+===========+=======+===============+===========+\n| extension_type | msg_type | pld_length | <padd   | pt_pld_1  | <padd | pt_pld_2  | <padd | pt_pld_rest   | <padding> |\n| U16            | U8       | U24        |   ing>  | 65519 B   |  ing> | 65519 B   |  ing> | 1 - 65519 B   |           |\n+----------------+----------+------------+---------+-------------------------------------------------------------------+\n\nThe `pld_length` field in the Encrypted Stratum message Header now consistently represents the plaintext length of the payload.\nSerialized stratum-v2 body (payload) is split into 65519-byte chunks and encrypted to form 65535-bytes AEAD ciphertexts,\nwhere `ct_pld_N` is the N-th ciphertext block of payload and `pt_pld_N` is the N-th plaintext block of payload.\n```\n\n## 4.7 URL Scheme and Pool Authority Key\n\nDownstream nodes that want to use the above outlined security scheme need to have configured the **Pool Authority Public Key** of the pool that they intend to connect to. It is provided by the target pool and communicated to its users via a trusted channel.\nAt least, it can be published on the pool's public website.\n\nThe key can be embedded into the mining URL as part of the path.\n\nAuthority Public key is [base58-check](https://en.bitcoin.it/wiki/Base58Check_encoding) encoded 32-byte secp256k1 public key (with implicit Y coordinate) prefixed with a LE u16 version prefix, currently `[1, 0]`:\n\n| [1, 0] | 2 bytes prefix |\n| ------ | -------------- |\n| PUBKEY | 32 bytes authority public key |\n\nURL example:\n\n```\n\nstratum2+tcp://thepool.com:34254/9bXiEd8boQVhq7WddEcERUL5tyyJVFYdU8th3HfbNXK3Yw6GRXh\n\n```\n\n### 4.7.1 Test vector:\n\n```\n\nraw_ca_public_key = [118, 99, 112, 0, 151, 156, 28, 17, 175, 12, 48, 11, 205, 140, 127, 228, 134, 16, 252, 233, 185, 193, 30, 61, 174, 227, 90, 224, 176, 138, 116, 85]\nprefixed_base58check = \"9bXiEd8boQVhq7WddEcERUL5tyyJVFYdU8th3HfbNXK3Yw6GRXh\"\n\n```\n\n## 4.8 References\n\n1. <a id=\"reference-1\"> https://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a>\n2. <a id=\"reference-2\"> https://www.secg.org/sec2-v2.pdf</a>\n3. <a id=\"reference-3\"> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki</a>\n4. <a id=\"reference-4\"> https://tools.ietf.org/html/rfc8439</a>\n5. <a id=\"reference-5\"> https://www.ietf.org/rfc/rfc2104.txt</a>\n6. <a id=\"reference-6\"> https://tools.ietf.org/html/rfc5869</a>\n7. <a id=\"reference-7\"> https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki</a>\n```\n",
    "html": "<h1>4 Protocol Security</h1>\n<p>Stratum V2 employs a type of encryption scheme called AEAD (authenticated encryption with associated data) to address the security aspects of all communication that occurs between clients and servers.\nThis provides both confidentiality and integrity for the ciphertexts (i.e. encrypted data) being transferred, as well as providing integrity for associated data which is not encrypted.\nPrior to opening any Stratum V2 channels for mining, clients MUST first initiate the cryptographic session state that is used to encrypt all messages sent between themselves and servers.\nThus, the cryptographic session state is independent of V2 messaging conventions.</p>\n<p>At the same time, this specification proposes optional use of a particular handshake protocol based on the <strong><a href=\"https://noiseprotocol.org/noise.html\">Noise Protocol framework</a></strong>.\nThe client and server establish secure communication using Diffie-Hellman (DH) key agreement, as described in greater detail in the Authenticated Key Agreement Handshake section below.</p>\n<p>Using the handshake protocol to establish secured communication is <strong>optional</strong> on the local network (e.g. local mining devices talking to a local mining proxy).\nHowever, it is <strong>mandatory</strong> for remote access to the upstream nodes, whether they be pool mining services, job declarating services or template distributors.</p>\n<h2>4.1 Motivation for Authenticated Encryption with Associated Data</h2>\n<p>Data transferred by the mining protocol MUST not provide adversary information that they can use to estimate the performance of any particular miner. Any intelligence about submitted shares can be directly converted to estimations of a miner’s earnings and can be associated with a particular username. This is unacceptable privacy leakage that needs to be addressed.</p>\n<h2>4.2 Motivation for Using the Noise Protocol Framework</h2>\n<p>The reasons why Noise Protocol Framework has been chosen are listed below:</p>\n<ul>\n<li>The Framework provides a formalism to describe the handshake protocol that can be verified.</li>\n<li>A custom certificate scheme is now possible (no need to use x509 certificates).</li>\n</ul>\n<h2>4.3 Choice of cryptographic primitives</h2>\n<p>Noise encrypted session requires Elliptic Curve (EC), Hash function (<code>HASH()</code>) and cipher function that supports AEAD mode<sup><a href=\"#reference-1\">1</a></sup>.</p>\n<p>This specification describes mandatory cryptographic primitives that each implementation needs to support.\nThese primitives are chosen so that Noise Encryption layer for Stratum V2 can be implemented using primitives already present in Bitcoin Core project at the time of writing this spec.</p>\n<h3>4.3.1 Elliptic Curve</h3>\n<ul>\n<li>Bitcoin’s secp256k1 curve<sup><a href=\"#reference-2\">2</a></sup> is used</li>\n<li>Schnorr signature scheme is used as described in BIP340<sup><a href=\"#reference-3\">3</a></sup></li>\n</ul>\n<h4>4.3.1.1 EC point encoding remarks</h4>\n<p>Secp256k1 curve points, i.e. Public Keys, are points with of X- and Y-coordinate.\nWe serialize them in three different ways, only using the x-coordinate.</p>\n<ol>\n<li>\n<p>When signing or verifying a certificate, we use the 32 byte x-only\nencoding as defined in BIP 340.<sup><a href=\"#reference-3\">3</a></sup>.</p>\n</li>\n<li>\n<p>When sharing keys during the handshake, whether in plain text or encrypted,\nwe use the 64 byte ElligatorSwift x-only encoding as defined in BIP324<sup><a href=\"#reference-7\">7</a></sup> under “ElligatorSwift encoding of curve X coordinates”. This encoding uses 64-bytes instead of 32-bytes in order to produce a\npseudo-random bytesteam. This is useful because the protocol handshake starts with\neach side sending their public key in plain text. Additionally the use of X-only\nElligatorSwift ECDH removes the need to grind or negate private keys.</p>\n</li>\n<li>\n<p>The Authority public key is base58-check encoded as described in 4.7.</p>\n</li>\n</ol>\n<p>Digital signatures are serialized in 64-bytes like in BIP340<sup><a href=\"#reference-3\">3</a></sup>.</p>\n<p>Key generation algorithm:</p>\n<ol>\n<li>generate random 32-byte secret key <code>sk</code></li>\n<li>let <code>d' = int(sk)</code></li>\n<li>fail if <code>d = 0</code> or <code>d' &gt; n</code> where <code>n</code> is group order of secp256k1 curve</li>\n<li>compute <code>P</code> as <code>d'⋅G</code></li>\n<li>drop the Y coordinate and compute (u, t) = XElligatorSwift(P.x)</li>\n<li>ellswift_pub = bytes(u) || bytes(t)</li>\n<li>output keypair <code>(sk, ellswift_pub)</code></li>\n</ol>\n<p>To perform X-only ECDH we use ellswift_ecdh_xonly(ellswift_theirs, d) as described in BIP324<sup><a href=\"#reference-7\">7</a></sup> under “Shared secret computation”. The result is 32 bytes.</p>\n<p>No assumption is made about the parity of Y-coordinate. For the purpose of signing\n(e.g. certificate) and ECDH (handshake) it is <em>not</em> necessary to “grind”\nthe private key. The choosen algoritms take care of this by implicitly negatating\nthe key, as if its public key had an even Y-coordinate.</p>\n<p>For more information refer to BIP340<sup><a href=\"#reference-3\">3</a></sup> and BIP324<sup><a href=\"#reference-7\">7</a></sup>.</p>\n<h3>4.3.2 Hash function</h3>\n<ul>\n<li><code>SHA-256()</code> is used as a <code>HASH()</code></li>\n</ul>\n<h3>4.3.3 Cipher function for authenticated encryption</h3>\n<ul>\n<li>Cipher has methods for encryption and decryption for key <code>k</code>, nonce <code>n</code>, associated_data <code>ad</code>, plaintext <code>pt</code> and ciphertext <code>ct</code>\n<ul>\n<li><code>ENCRYPT(k, n, ad, pt)</code></li>\n<li><code>DECRYPT(k, n, ad, ct)</code></li>\n</ul>\n</li>\n<li>ChaCha20 and Poly1305 in AEAD mode<sup><a href=\"#reference-4\">4</a></sup> (ChaChaPoly) is used as a default AEAD cipher</li>\n</ul>\n<h2>4.4 Cryptographic operations</h2>\n<h3>4.4.1 CipherState object</h3>\n<p>Object that encapsulates encryption and decryption operations with underlying AEAD mode cipher functions using 32-byte encryption key <code>k</code> and 8-byte nonce <code>n</code>.\nCipherState has the following interface:</p>\n<ul>\n<li><code>InitializeKey(key)</code>:\n<ul>\n<li>Sets <code>k = key</code>, <code>n = 0</code></li>\n</ul>\n</li>\n<li><code>EncryptWithAd(ad, plaintext)</code>\n<ul>\n<li>If <code>k</code> is non-empty, performs <code>ENCRYPT(k, n++, ad, plaintext)</code> on the underlying cipher function, otherwise returns <code>plaintext</code>. The <code>++</code> post-increment operator applied to <code>n</code> means: “use the current n value, then increment it”.</li>\n<li>Where <code>ENCRYPT</code> is an evaluation of <code>ChaCha20-Poly1305</code> (IETF variant) with the passed arguments, with nonce <code>n</code> encoded as 32 zero bits, followed by a <em>little-endian</em> 64-bit value. Note: this follows the Noise Protocol convention, rather than our normal endian.</li>\n</ul>\n</li>\n<li><code>DecryptWithAd(ad, ciphertext)</code>\n<ul>\n<li>If <code>k</code> is non-empty performs <code>DECRYPT(k, n++, ad, plaintext)</code> on the underlying cipher function, otherwise returns ciphertext. If an authentication failure occurs in <code>DECRYPT()</code> then <code>n</code> is not incremented and an error is signaled to the caller.</li>\n<li>Where <code>DECRYPT</code> is an evaluation of <code>ChaCha20-Poly1305</code> (IETF variant) with the passed arguments, with nonce <code>n</code> encoded as 32 zero bits, followed by a <em>little-endian</em> 64-bit value.</li>\n</ul>\n</li>\n</ul>\n<h3>4.4.2 Handshake Operation</h3>\n<p>Throughout the handshake process, each side maintains these variables:</p>\n<ul>\n<li><code>ck</code>: <strong>chaining key</strong>. Accumulated hash of all previous ECDH outputs. At the end of the handshake <code>ck</code> is used to derive encryption key <code>k</code>.</li>\n<li><code>h</code>: <strong>handshake hash</strong>. Accumulated hash of <em>all</em> handshake data that has been sent and received so far during the handshake process</li>\n<li><code>e</code>, <code>re</code> <strong>ephemeral keys</strong>. Ephemeral key and remote party’s ephemeral key, respectively.</li>\n<li><code>s</code>, <code>rs</code> <strong>static keys</strong>. Static key and remote party’s static key, respectively.</li>\n</ul>\n<p>The following functions will also be referenced:</p>\n<ul>\n<li>\n<p><code>generateKey()</code>: generates and returns a fresh <code>secp256k1</code> keypair</p>\n<ul>\n<li>Where the object returned by <code>generateKey</code> has two attributes:\n<ul>\n<li><code>.public_key</code>, which returns an abstract object representing the public key</li>\n<li><code>.private_key</code>, which represents the private key used to generate the public key</li>\n</ul>\n</li>\n<li>Where the public_key object also has a single method:\n<ul>\n<li><code>.serializeEllSwift()</code> that outputs a 64-byte EllSwift encoded serialization of the X-coordinate of EC point (the Y-coordinate is ignored)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>a || b</code> denotes the concatenation of two byte strings <code>a</code> and <code>b</code></p>\n</li>\n<li>\n<p><code>HMAC-HASH(key, data)</code></p>\n<ul>\n<li>Applies HMAC defined in <code>RFC 2104</code><sup><a href=\"#reference-5\">5</a></sup></li>\n<li>In our case where the key is always 32 bytes, this reduces down to:\n<ul>\n<li>pad the key with zero bytes to fill the hash block (block length is 64 bytes in case of SHA-256): <code>k' = k || &lt;zero-bytes&gt;</code></li>\n<li>calculate <code>temp = SHA-256((k' XOR ipad) || data)</code> where ipad is repeated 0x36 byte</li>\n<li>output <code>SHA-256((k' XOR opad) || temp)</code> where opad is repeated 0x5c byte</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>HKDF(chaining_key, input_key_material)</code>: a function defined in <code>RFC 5869</code><sup><a href=\"#reference-6\">6</a></sup>, evaluated with a zero-length <code>info</code> field and 2 <code>num_output</code> field:</p>\n<ul>\n<li>Sets <code>temp_key = HMAC-HASH(chaining_key, input_key_material)</code></li>\n<li>Sets <code>output1 = HMAC-HASH(temp_key, byte(0x01))</code></li>\n<li>Sets <code>output2 = HMAC-HASH(temp_key, output1 || byte(0x02))</code></li>\n<li>Returns the pair <code>(output1, output2)</code></li>\n</ul>\n</li>\n<li>\n<p><code>MixKey(input_key_material)</code>: Executes the following steps:</p>\n<ul>\n<li>sets <code>(ck, temp_k) = HKDF(ck, input_key_material, 2)</code></li>\n<li>calls <code>InitializeKey(temp_k)</code></li>\n</ul>\n</li>\n<li>\n<p><code>MixHash(data)</code>: Sets <code>h = HASH(h || data)</code></p>\n</li>\n<li>\n<p><code>EncryptAndHash(plaintext)</code>:</p>\n<ul>\n<li>If <code>k</code> is non-empty sets <code>ciphertext = EncryptWithAd(h, plaintext)</code>, otherwise <code>ciphertext = plaintext</code></li>\n<li>Calls <code>MixHash(ciphertext)</code></li>\n<li>returns <code>ciphertext</code></li>\n</ul>\n</li>\n<li>\n<p><code>DecryptAndHash(ciphertext)</code>:</p>\n<ul>\n<li>If <code>k</code> is non-empty sets <code>plaintext = DecryptWithAd(h, ciphertext)</code>, otherwise <code>plaintext = ciphertext</code></li>\n<li>Calls <code>MixHash(ciphertext)</code></li>\n<li>returns <code>plaintext</code></li>\n</ul>\n</li>\n<li>\n<p><code>ECDH(k, rk)</code>: performs an Elliptic-Curve Diffie-Hellman operation\nusing <code>k</code>, which is a   valid <code>secp256k1</code> private key, and <code>rk</code>, which is a EllSwift\nencoded public key</p>\n<ul>\n<li>The output is 32 bytes</li>\n<li>It is a shortcut for performing operation <code>v2_ecdh</code> defined in BIP324<sup><a href=\"#reference-7\">7</a></sup>:\n<ul>\n<li>let <code>k, ellswift_k</code> be key pair created by <code>ellswift_create()</code> function</li>\n<li>let <code>rk</code> be remote public key <strong>encoded as ellswift</strong>.</li>\n<li>let <code>initiator</code> be bool flag that is <strong>true</strong> if the party performing ECDH initiated the handshake</li>\n<li>then <code>ECDH(k, rk) = v2_ecdh(k, ellswift_k, rk, initiator)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>v2_ecdh(k, ellswift_k, rk, initiator)</code>:</p>\n<ul>\n<li>let <code>ecdh_point_x32</code> = <code>ellswift_ecdh_xonly(rk, k)</code></li>\n<li>if initiator == true:\n<ul>\n<li>return <code>tagged_hash(ellswift_k, rk, ecdh_point_x32)</code></li>\n<li>else return <code>tagged_hash(rk, ellswift_k, ecdh_point_x32)</code></li>\n</ul>\n</li>\n<li><strong>Note that the ecdh result is not commutative with respect to roles! Therefore the initiator flag is needed</strong></li>\n</ul>\n</li>\n<li>\n<p><code>ellswift_ecdh_xonly</code> - see BIP324<sup><a href=\"#reference-7\">7</a></sup></p>\n</li>\n<li>\n<p><code>tagged_hash(a, b, c)</code>:</p>\n<ul>\n<li>let tag = <code>SHA256(&quot;bip324_ellswift_xonly_ecdh&quot;)</code></li>\n<li>return <code>SHA256(concatenate(tag, tag, a, b, c))</code></li>\n</ul>\n</li>\n</ul>\n<h2>4.5 Authenticated Key Agreement Handshake</h2>\n<p>The handshake chosen for the authenticated key exchange is an <strong><code>Noise_NX</code></strong> augmented by server authentication with simple 2 level public key infrastructure.</p>\n<p>The complete authenticated key agreement (<code>Noise NX</code>) is performed in three distinct steps (acts).</p>\n<ol>\n<li>NX-handshake part 1: <code>-&gt; e</code></li>\n<li>NX-handshake part 2: <code>&lt;- e, ee, s, es, SIGNATURE_NOISE_MESSAGE</code></li>\n<li>Server authentication: Initiator validates authenticity of server using from <code>SIGNATURE_NOISE_MESSAGE</code></li>\n</ol>\n<p>Should the decryption (i.e. authentication code validation) fail at any point, the session must be terminated.</p>\n<h3>4.5.1 Handshake Act 1: NX-handshake part 1 <code>-&gt; e</code></h3>\n<p>Prior to starting first round of NX-handshake, both initiator and responder initializes handshake variables <code>h</code> (hash output), <code>ck</code> (chaining key) and <code>k</code> (encryption key):</p>\n<ol>\n<li><strong>hash output</strong> <code>h = HASH(protocolName)</code></li>\n</ol>\n<ul>\n<li>Since <code>protocolName</code> more than 32 bytes in length, apply <code>HASH</code> to it.</li>\n<li><code>protocolName</code> is official noise protocol name: <code>Noise_NX_Secp256k1+EllSwift_ChaChaPoly_SHA256</code>\nencoded as an ASCII string</li>\n</ul>\n<ol start=\"2\">\n<li><strong>chaining key</strong> <code>ck = h</code></li>\n<li><strong>hash output</strong> <code>h = HASH(h)</code></li>\n<li><strong>encryption key</strong> <code>k </code> empty</li>\n</ol>\n<h4>4.5.1.1 Initiator</h4>\n<p>Initiator generates ephemeral keypair and sends the public key to the responder:</p>\n<ol>\n<li>initializes empty output buffer</li>\n<li>generates ephemeral keypair <code>e</code>, appends <code>e.public_key.serializeEllSwift()</code> to the buffer (64 bytes plaintext EllSwift encoded public key)</li>\n<li>calls <code>MixHash(e.public_key)</code></li>\n<li>calls <code>EncryptAndHash()</code> with empty payload and appends the ciphertext to the buffer (note that <em>k</em> is empty at this point, so this effectively reduces down to <code>MixHash()</code> on empty data)</li>\n<li>submits the buffer for sending to the responder in the following format</li>\n</ol>\n<h5>Ephemeral public key message:</h5>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PUBKEY</td>\n<td>Initiator’s ephemeral public key</td>\n</tr>\n</tbody>\n</table>\n<p>Message length: 64 bytes</p>\n<h4>4.5.1.2 Responder</h4>\n<ol>\n<li>receives ephemeral public key message (64 bytes plaintext EllSwift encoded public key)</li>\n<li>parses received public key as <code>re.public_key</code></li>\n<li>calls <code>MixHash(re.public_key)</code></li>\n<li>calls <code>DecryptAndHash()</code> on remaining bytes (i.e. on empty data with empty <em>k</em>, thus effectively only calls <code>MixHash()</code> on empty data)</li>\n</ol>\n<h3>4.5.2 Handshake Act 2: NX-handshake part 2 <code>&lt;- e, ee, s, es, SIGNATURE_NOISE_MESSAGE</code></h3>\n<p>Responder provides its ephemeral, encrypted static public keys and encrypted <code>SIGNATURE_NOISE_MESSAGE</code> to the initiator, performs Elliptic-Curve Diffie-Hellman operations.</p>\n<h5>SIGNATURE_NOISE_MESSAGE</h5>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>version</td>\n<td>U16</td>\n<td>Version of the certificate format</td>\n</tr>\n<tr>\n<td>valid_from</td>\n<td>U32</td>\n<td>Validity start time (unix timestamp)</td>\n</tr>\n<tr>\n<td>not_valid_after</td>\n<td>U32</td>\n<td>Signature is invalid after this point in time (unix timestamp)</td>\n</tr>\n<tr>\n<td>signature</td>\n<td>SIGNATURE</td>\n<td>Certificate signature</td>\n</tr>\n</tbody>\n</table>\n<p>Length: 74 bytes</p>\n<h4>4.5.2.1 Responder</h4>\n<ol>\n<li>initializes empty output buffer</li>\n<li>generates ephemeral keypair <code>e</code>, appends <code>e.public_key</code> to the buffer (64 bytes plaintext EllSwift encoded public key)</li>\n<li>calls <code>MixHash(e.public_key)</code></li>\n<li>calls <code>MixKey(ECDH(e.private_key, re.public_key))</code></li>\n<li>appends <code>EncryptAndHash(s.public_key)</code> (64 bytes encrypted EllSwift encoded public key, 16 bytes MAC)</li>\n<li>calls <code>MixKey(ECDH(s.private_key, re.public_key))</code></li>\n<li>appends <code>EncryptAndHash(SIGNATURE_NOISE_MESSAGE)</code> to the buffer</li>\n<li>submits the buffer for sending to the initiator</li>\n<li>return pair of CipherState objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction:\n<ol>\n<li>sets <code>temp_k1, temp_k2 = HKDF(ck, zerolen, 2)</code></li>\n<li>creates two new CipherState objects <code>c1</code> and <code>c2</code></li>\n<li>calls <code>c1.InitializeKey(temp_k1)</code> and <code>c2.InitializeKey(temp_k2)</code></li>\n<li>returns the pair <code>(c1, c2)</code></li>\n</ol>\n</li>\n</ol>\n<h5>Message format of NX-handshake part 2</h5>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PUBKEY</td>\n<td>Responder’s plaintext ephemeral public key</td>\n</tr>\n<tr>\n<td>PUBKEY</td>\n<td>Responder’s encrypted static public key</td>\n</tr>\n<tr>\n<td>MAC</td>\n<td>Message authentication code for responder’s static public key</td>\n</tr>\n<tr>\n<td>SIGNATURE_NOISE_MESSAGE</td>\n<td>Signed message containing Responder’s static key. Signature is issued by authority that is generally known to operate the server acting as the noise responder</td>\n</tr>\n<tr>\n<td>MAC</td>\n<td>Message authentication code for SIGNATURE_NOISE_MESSAGE</td>\n</tr>\n</tbody>\n</table>\n<p>Message length: 170 bytes</p>\n<h4>4.5.2.2 Initiator</h4>\n<ol>\n<li>receives NX-handshake part 2 message</li>\n<li>interprets first 64 bytes as EllSwift encoded <code>re.public_key</code></li>\n<li>calls <code>MixHash(re.public_key)</code></li>\n<li>calls <code>MixKey(ECDH(e.private_key, re.public_key))</code></li>\n<li>decrypts next 80 bytes with <code>DecryptAndHash()</code> and stores the results as <code>rs.public_key</code> which is <strong>server’s static public key</strong> (note that 64 bytes is the public key and 16 bytes is MAC)</li>\n<li>calls <code>MixKey(ECDH(e.private_key, rs.public_key)</code></li>\n<li>decrypts next 90 bytes with <code>DecryptAndHash()</code> and deserialize plaintext into <code>SIGNATURE_NOISE_MESSAGE</code> (74 bytes data + 16 bytes MAC)</li>\n<li>return pair of CipherState objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction:\n<ol>\n<li>sets <code>temp_k1, temp_k2 = HKDF(ck, zerolen, 2)</code></li>\n<li>creates two new CipherState objects <code>c1</code> and <code>c2</code></li>\n<li>calls <code>c1.InitializeKey(temp_k1)</code> and <code>c2.InitializeKey(temp_k2)</code></li>\n<li>returns the pair <code>(c1, c2)</code></li>\n</ol>\n</li>\n</ol>\n<h3>4.5.3 Server authentication</h3>\n<p>During the handshake, initiator receives <code>SIGNATURE_NOISE_MESSAGE</code> and <strong>server’s static public key</strong>. These parts make up a <code>CERTIFICATE</code> signed by an authority whose public key is generally known (for example from pool’s website). Initiator confirms the identity of the server by verifying the signature in the certificate.</p>\n<h5>CERTIFICATE</h5>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n<th>Signed field</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>version</td>\n<td>U16</td>\n<td>Version of the certificate format</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>valid_from</td>\n<td>U32</td>\n<td>Validity start time (unix timestamp)</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>not_valid_after</td>\n<td>U32</td>\n<td>Signature is invalid after this point in time (unix timestamp)</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>server_public_key</td>\n<td>PUBKEY</td>\n<td>Server’s static public key that was used during NX handshake</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>authority_public_key</td>\n<td>PUBKEY</td>\n<td>Certificate authority’s public key that signed this message</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>signature</td>\n<td>SIGNATURE</td>\n<td>Signature over the serialized fields marked for signing</td>\n<td>NO</td>\n</tr>\n</tbody>\n</table>\n<p>This message is not sent directly. Instead, it is constructed from SIGNATURE_NOISE_MESSAGE and server’s static public\nkey that are sent during the handshake process</p>\n<p>The PUBKEY fields are encoded using only their 32 byte x-coordinate and <em>not</em> with\nEllSwift. For the purpose of generating and verifying the certificate, the 64 byte\nEllSwift encoded server_public_key can be decoded to its 32 byte x-coordinate.</p>\n<h4>4.5.3.1 Signature structure</h4>\n<p>Schnorr signature with <em>key prefixing</em> is used<sup><a href=\"#reference-3\">3</a></sup></p>\n<p>signature is constructed for</p>\n<ul>\n<li>message <code>m</code>, where <code>m</code> is <code>HASH</code> of the serialized fields of the <code>CERTIFICATE</code> that are marked for signing, i.e. <code>m = SHA-256(version || valid_from || not_valid_after || server_public_key)</code></li>\n<li>public key <code>P</code> that is Certificate Authority</li>\n</ul>\n<p>Signature itself is concatenation of an EC point <code>R</code> and an integer <code>s</code> (note that each item is serialized as 32 bytes array) for which identity <code>s⋅G = R + HASH(R || P || m)⋅P</code> holds.</p>\n<h2>4.6 Encrypted stratum message framing</h2>\n<p>After handshake process is finished, both initiator and responder have CipherState objects for encryption and decryption and after initiator validated server’s identity, any subsequent traffic is encrypted and decrypted with <code>EncryptWithAd()</code> and <code>DecryptWithAd()</code> methods of the respective CipherState objects with zero-length associated data.</p>\n<p>Maximum transport message length (ciphertext) is for noise protocol message 65535 bytes.</p>\n<p>Since Stratum Message Frame consists of</p>\n<ul>\n<li>fixed length message header: 6 bytes</li>\n<li>variable length serialized stratum message</li>\n</ul>\n<p>Stratum Message header and stratum message payload are processed separately.</p>\n<h4>Encrypting stratum message</h4>\n<ol>\n<li>serialize stratum message into a plaintext binary string (payload)</li>\n<li>prepare the frame header for the Stratum message <code>message_length</code> is the length of the plaintext payload.</li>\n<li>encrypt and concatenate serialized header and payload:\n4. <code>EncryptWithAd([], header)</code> - 22 bytes\n5. <code>EncryptWithAd([], payload)</code> - variable length encrypted message</li>\n<li>concatenate resulting header and payload ciphertext</li>\n</ol>\n<ul>\n<li>Note: The <code>message_length</code> (payload_length) in the encrypted Stratum message header always reflects the plaintext payload size. The size of the encrypted payload is implicitly understood to be message_length + MAC size for each block. This simplifies the decryption process and ensures clarity in interpreting frame data.</li>\n</ul>\n<h4>Decrypting stratum message</h4>\n<ol>\n<li>read exactly 22 bytes and decrypt into stratum frame or fail\n2.The value <code>frame.message_length</code> should first be converted to the ciphertext length, and then that amount of data should be read and decrypted into plaintext payload. If decryption fails, the process stops</li>\n<li>deserialize plaintext payload into stratum message given by <code>frame.extension_type</code> and <code>frame.message_type</code> or fail</li>\n</ol>\n<p>*converting plaintext length to ciphertext length:</p>\n<pre><code class=\"language-c\">#define MAX_CT_LEN 65535\n#define MAC_LEN 16\n#define MAX_PT_LEN (MAX_CT_LEN - MAC_LEN)\n\nuint pt_len_to_ct_len(uint pt_len) {\n        uint remainder;\n        remainder = pt_len % MAX_PT_LEN;\n        if (remainder &gt; 0) {\n                remainder += MAC_LEN;\n        }\n        return pt_len / MAX_PT_LEN * MAX_CT_LEN + remainder;\n}\n</code></pre>\n<h4>Encrypted stratum message frame layout</h4>\n<pre><code>+--------------------------------------------------+-------------------------------------------------------------------+\n| Extended noise header                            | Encrypted stratum-message payload                                 |\n+--------------------------------------------------+-------------------+-------------------+---------------------------+\n| Header AEAD ciphertext                           | Noise block 1     | Noise block 2     | Last Noise block          |\n| 22 Bytes                                         | 65535 Bytes       | 65535 Bytes       | 17 - 65535 Bytes          |\n+----------------------------------------+---------+-----------+-------+-----------+-------+---------------+-----------+\n| Encrypted Stratum message Header       | MAC     | ct_pld_1  | MAC_1 | ct_pld_2  | MAC_2 | ct_pld_rest   | MAC_rest  |\n| 6 Bytes                                | 16 B    | 65519 B   | 16 B  | 65519 B   | 16 B  | 1 - 65519 B   | 16 Bytes  |\n+================+==========+============+=========+===========+=======+===========+=======+===============+===========+\n| extension_type | msg_type | pld_length | &lt;padd   | pt_pld_1  | &lt;padd | pt_pld_2  | &lt;padd | pt_pld_rest   | &lt;padding&gt; |\n| U16            | U8       | U24        |   ing&gt;  | 65519 B   |  ing&gt; | 65519 B   |  ing&gt; | 1 - 65519 B   |           |\n+----------------+----------+------------+---------+-------------------------------------------------------------------+\n\nThe `pld_length` field in the Encrypted Stratum message Header now consistently represents the plaintext length of the payload.\nSerialized stratum-v2 body (payload) is split into 65519-byte chunks and encrypted to form 65535-bytes AEAD ciphertexts,\nwhere `ct_pld_N` is the N-th ciphertext block of payload and `pt_pld_N` is the N-th plaintext block of payload.\n</code></pre>\n<h2>4.7 URL Scheme and Pool Authority Key</h2>\n<p>Downstream nodes that want to use the above outlined security scheme need to have configured the <strong>Pool Authority Public Key</strong> of the pool that they intend to connect to. It is provided by the target pool and communicated to its users via a trusted channel.\nAt least, it can be published on the pool’s public website.</p>\n<p>The key can be embedded into the mining URL as part of the path.</p>\n<p>Authority Public key is <a href=\"https://en.bitcoin.it/wiki/Base58Check_encoding\">base58-check</a> encoded 32-byte secp256k1 public key (with implicit Y coordinate) prefixed with a LE u16 version prefix, currently <code>[1, 0]</code>:</p>\n<table>\n<thead>\n<tr>\n<th>[1, 0]</th>\n<th>2 bytes prefix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PUBKEY</td>\n<td>32 bytes authority public key</td>\n</tr>\n</tbody>\n</table>\n<p>URL example:</p>\n<pre><code>\nstratum2+tcp://thepool.com:34254/9bXiEd8boQVhq7WddEcERUL5tyyJVFYdU8th3HfbNXK3Yw6GRXh\n\n</code></pre>\n<h3>4.7.1 Test vector:</h3>\n<pre><code>\nraw_ca_public_key = [118, 99, 112, 0, 151, 156, 28, 17, 175, 12, 48, 11, 205, 140, 127, 228, 134, 16, 252, 233, 185, 193, 30, 61, 174, 227, 90, 224, 176, 138, 116, 85]\nprefixed_base58check = &quot;9bXiEd8boQVhq7WddEcERUL5tyyJVFYdU8th3HfbNXK3Yw6GRXh&quot;\n\n</code></pre>\n<h2>4.8 References</h2>\n<ol>\n<li><a id=\"reference-1\"> https://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf</a></li>\n<li><a id=\"reference-2\"> https://www.secg.org/sec2-v2.pdf</a></li>\n<li><a id=\"reference-3\"> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki</a></li>\n<li><a id=\"reference-4\"> https://tools.ietf.org/html/rfc8439</a></li>\n<li><a id=\"reference-5\"> https://www.ietf.org/rfc/rfc2104.txt</a></li>\n<li><a id=\"reference-6\"> https://tools.ietf.org/html/rfc5869</a></li>\n<li><a id=\"reference-7\"> https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki</a></li>\n</ol>\n<pre><code></code></pre>\n"
  },
  "05-Mining-Protocol": {
    "slug": "05-Mining-Protocol",
    "content": "# 5. Mining Protocol\n\nThe Mining Protocol enables the distribution of work to mining devices and the submission of proof-of-work results.\n\nIt can be used without Job Declaration and Template Distribution Protocols, where a subset of the messages are used by a pool to unilaterally distribute work to miners.\n\nAlternatively, it can be used in conjunction with Job Declaration and Template Distribution Protocols, where both pool and miners coordinate to decide what is valid work.\n\n## 5.1 Job\n\nA **Job** consists of a unit of work containing all the necessary information about the hashing space over some candidate block header.\n\nEach Mining Device has to work on a unique part of the whole search space.\nThe full search space is defined in part by valid values in the following block header fields:\n\n- `nonce` header field (32 bits)\n- `version` header field (16 bits, as specified by [BIP 320](https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki))\n- `nTime` header field (32 bits timestamp, limited under [`MAX_FUTURE_BLOCK_TIME`](https://github.com/bitcoin/bitcoin/blob/28ce159bc327e6dfec34077ff2e379b23a95db65/src/chain.h#L29))\n\nThe other portion of the block header that is used to define the full search space is the Merkle Root, which is deterministically computed from:\n- Coinbase transaction\n- Transaction set\n\nAll roles in Stratum v2 MUST NOT use transaction selection/ordering for additional hash space extension.\nThis stems both from the concept that miners/pools should be able to choose their transaction set freely without any interference with the protocol, and also to enable future protocol modifications to Bitcoin.\nIn other words, any rules imposed on transaction selection/ordering by miners not described in the rest of this document may result in invalid work.\n\nMining servers MUST assign a unique subset of the search space to each mining device, otherwise the mining devices will waste energy with overlapping search.\n\nThis protocol explicitly expects that upstream server software is able to manage the size of the hashing space correctly for its clients and can provide new and unique Jobs quickly enough, based on the hashpower of each client.\n\nThe protocol defines two main types of Jobs: **Standard Job** and **Extended Job**.\n\nThis separation vastly simplifies the protocol implementation for clients that don’t support Extended Job, as they only need to implement the subset of protocol messages related to Standard Job (see Mining Protocol Messages for details).\n\nAdditionally, a Job (either Standard or Extended) also could be potentially labeled as a **Future Job** and/or **Custom Job**.\n\n### 5.1.1 Standard Job\n\nStandard Jobs are restricted to fixed Merkle Roots, where the only modifiable bits are under the `version`, `nonce`, and `nTime` fields of the block header.\n\nWe call this header-only mining (HOM), and it is the smallest assignable unit of search space by the protocol.\n\nThe size of the search space for one Standard Job, given a fixed `nTime` field, is `2^(NONCE_BITS + BIP320_VERSION_ROLLING_BITS) = ~280Th`, where `NONCE_BITS = 32` and `BIP320_VERSION_ROLLING_BITS = 16`.\nThis is a guaranteed space before `nTime` rolling (or changing the Merkle Root by sending a new Job).\n\nStandard Jobs are distributed via the [`NewMiningJob`](#5315-newminingjob-server---client) message, which can ONLY be sent via [Standard Channels](#521-standard-channels).\n\nNote that Mining Devices with hashrate above 280 TH/s will outrun the true time when rolling the `nTime` field. This is not necessarily a problem, as long as the Job remains valid within the limits defined by the `MAX_FUTURE_BLOCK_TIME` constant of the Bitcoin protocol (2 hours).\n\nDepending on the hashrate of the Mining Device, it must receive new Standard Jobs (with a different Merkle Root) frequently enough in order to avoid rolling `nTime` too much ahead of the true time (which could result in rejected work).\n\n![](./img/standard_job.png)\n\n### 5.1.2 Extended Job\n\nExtended Jobs allow rolling Merkle Roots, giving extensive control over the search space so that they can implement various advanced use cases such as:\n- translation between Sv1 and Sv2 protocols\n- difficulty aggregation\n- search space splitting\n\nExtended Jobs are distributed via the [`NewExtendedMiningJob`](#5416-newextendedminingjob-server---client) message, which can be sent via:\n- [Group Channels](#523-group-channels)\n- [Extended Channels](#522-extended-channels)\n\n![](./img/extended_job.png)\n\n#### 5.1.2.1 Extended Extranonce\n\nDownstream and Upstream are relative terms. There could theoretically be multiple nested layers of Stratum Nodes (e.g.: Proxies) between a Work-Providing Node and a Mining Device.\n\nSo the protocol establishes the notion of **Extended Extranonce**, which is a fundamental component of Extended Jobs.\n\nThe Extended Extranonce is an array of bytes, split into three different areas:\n\n![](./img/extended_extranonce.png)\n\n- The `extranonce_prefix` bytes are reserved for the upstream layer, where fixed bytes were already established for the Extranonce and are no longer available for rolling or search space splitting.\n- The **locally reserved** bytes is where the local layer will assign unique values for its own downstream clients, according to their hashpower.\n- The **downstream reserved** bytes is where the downstream clients will further distribute the search space, or use for rolling (if they are Mining Devices).\n\n![](./img/extended_extranonce_layers.png)\n\nIn order to calculate the Merkle Root, an Extended Job carries the following data:\n- `merkle_path`\n- `coinbase_tx_prefix`\n- `coinbase_tx_suffix`\n\nAn [Extended Channel](#532-extended-channels) has the following properties:\n- `extranonce_prefix`: the Extended Extranonce bytes that were already allocated by the upstream server.\n- `extranonce_size`: how many bytes are available for the locally reserved and downstream reserved areas of the Extended Extranonce.\n\nAnd a [Standard Channel](#531-standard-channels) has the following property:\n- `extranonce_prefix` the Extended Extranonce bytes that were already allocated by the upstream server.\n\nSo when some layer receives an Extended Job, it could either:\n- propagate it as an Extended Job to a downstream Extended or Group Channel (via `NewExtendedMiningJob` notification), where the Extended Extranonce will be further split.\n- convert it into multiple Standard Job notifications (`NewMiningJob`), where each downstream Standard Channel's `extranonce_prefix` is combined with `coinbase_tx_prefix` + `coinbase_tx_suffix`.\n\nFor conversion into Standard Jobs, the Coinbase Transaction is constructed by concatenating these fields in this specific order: `coinbase_tx_prefix + extranonce_prefix + coinbase_tx_suffix`.\n\nThe Coinbase Transaction is then combined with the `merkle_path` of the Extended Job to calculate the `merkle_root` for the Standard Job notification (`NewMiningJob`). Since Standard Jobs are HOM, there's no `extranonce_size` field on the Standard Job notification.\n\n### 5.1.3 Future Job\n\nA Job with an empty template or speculated non-empty template can be sent in advance to speedup Job distribution when a new block is found on the network.\n\nThe mining server MAY have precomputed such a Job and is able to pre-distribute it for all active Channels.\nThe only missing information to start to mine on the new block is the new `prev_hash`.\nThis information can be provided independently.\n\nSuch an approach improves the efficiency of the protocol where the upstream node does not waste precious time immediately after a new block is found in the network.\n\nThe trade-off here is that a non-empty Future Job could potentially contain a transaction that was already included in the block that was just propagated on the network, which would lead to an invalid block if successfully mined.\n\nSo mining servers that provide non-empty Future Jobs SHOULD:\n- never send a `SetNewPrevHash` for a Future Job that was later found to contain a conflicting transaction.\n- minimize the probability of Future Jobs containing conflicting transactions (which leads to Future Jobs carrying less profitable templates).\n- after a `SetNewPrevHash` is propagated for a Future Job, provide a non-Future Job for this same `prev_hash` as fast as possible (with a more profitable template).\n\n### 5.1.4 Custom Job\n\nA Custom Job contains a set of transactions that were chosen by the miner instead of being unilaterally imposed by the Pool.\n\nUnder the Job Declaration Protocol, upon request the Job Declarator Server (JDS) sends a `mining_job_token` to the Job Declarator Client.\n\nThis `mining_job_token` is used by JDC for:\n- declaring a Custom Job to JDS (via `DeclareMiningJob` message of Job Declaration Protocol)\n- notifying Pool about a Custom Job (via `SetCustomMiningJob` message of Mining Protocol)\n\nThis is a key feature of Stratum V2 that improves Bitcoin decentralization. Please see Job Declaration Protocol for more details.\n\n## 5.2 Channel\n\nThe Mining Protocol is designed such that downstream Mining Devices open Channels with upstream Stratum Nodes within established Connections.\nThese upstream Stratum Nodes could be actual Work-Providing Nodes (e.g.: Pool, or Job Declarator Client) or simply Proxies that relay messages forward.\n\nEach Channel identifies a dedicated mining session associated with an authorized user.\nUpstream stratum nodes accept work submissions and specify a mining target on a per-channel basis.\n\nThere can theoretically be up to `2^32` open Channels within one Connection. This is however just a theoretical ceiling, and it does not mean that every Connection will be able to fill this full capacity (maybe the search space has already been narrowed).\n\nAll Channels are independent of each other, but share some messages broadcast from the server for higher efficiency (e.g. information about a new `prev_hash`).\nEach Channel is identified by its `channel_id` (`U32`), which is consistent throughout the whole life of the Connection. There MUST NOT be two Channels with the same ID in the same Connection.\n\nA Proxy can either transparently allow its clients to open separate Channels with the server (preferred behavior), or aggregate open connections from downstream devices into its own open channel with the server and translate the messages accordingly (present mainly for allowing v1 proxies).\nBoth options have some practical use cases.\nIn either case, proxies SHOULD aggregate clients' Channels into a smaller number of Connections.\nThis saves network traffic for broadcast messages sent by a server because fewer messages need to be sent in total, which leads to lower latencies as a result.\nAnd it further increases efficiency by allowing larger packets to be sent.\n\nThe protocol defines three types of Channels: **Standard Channel**, **Extended Channel** and **Group Channel**, which are useful for different purposes.\n\n### 5.2.1 Standard Channel\n\nStandard Channels are created by end Mining Devices.\n\nWhen an end Mining Device opens a Standard Channel with an upstream, it is restricted to Standard Jobs (via `REQUIRES_STANDARD_JOBS` bit flag of `SetupConnection` message).\n\nHowever, a Proxy could also transparently relay the Standard Channels from the downstream Mining Devices into new upstream Connections. In this case, the `REQUIRES_STANDARD_JOBS` bit flag will not be set for the `SetupConnection` message. This indicates that on this Connection, the Standard Channels can be assembled into a Group Channel and receive Extended Jobs for efficient distribution downstream.\n\nThen, the Connections between the Proxy and Mining Devices will receive Standard Jobs that were efficiently distributed from the Extended Jobs. The Merkle Root of each Standard Job is calculated by the Proxy, taking in consideration the `extranonce_prefix` that was assigned to each Standard Channel, plus the `coinbase_tx_prefix` and the `coinbase_tx_suffix` that were sent on the Extended Job. No `extranonce` field is used in this scenario.\n\n### 5.2.2 Extended Channel\n\nExtended Channels are intended to be used by Proxies for a more efficient distribution of hashing space.\n\nAn Extended Channel carries the following properties:\n- `extranonce_prefix`: the Extended Extranonce bytes that were already allocated by the upstream server.\n- `extranonce_size`: how many bytes are available for the locally reserved and downstream reserved areas of the Extended Extranonce.\n\nUpstream servers which accept connections and provide work MUST support Extended Channels.\nClients, on the other hand, do not have to support Extended Channels, as they MAY be implemented more simply with only Standard Channels at the end-device level.\nThus, upstream servers providing work MUST also support Standard Channels.\n\nThe size of search space for an Extended Channel is `2^(nonce_bits + version_rolling_bits + extranonce_size*8)` per `nTime` value.\n\n### 5.2.3 Group Channel\n\nStandard channels opened within one particular connection can be grouped together to be addressable by a common communication group channel.\n\nWhenever a Standard Channel is created, it is always put into some Group Channel identified by its `group_channel_id`.\nGroup Channel ID namespace is the same as Standard Channel ID namespace on a particular connection.\n\n## 5.3 Mining Protocol Messages\n\n### 5.3.1 `SetupConnection` Flags for Mining Protocol\n\nFlags usable in `SetupConnection.flags` and `SetupConnection.Error::flags`, where bit 0 is the least significant bit of the u32 type:\n\n| Flag Name                | Bit | Description                                                                         |\n|--------------------------| --- | ----------------------------------------------------------------------------------- |\n| REQUIRES_STANDARD_JOBS   | 0   | The downstream node requires standard jobs. It does not understand group channels - |\n|                          |     | it is unable to process extended jobs sent to standard channels through a group     |\n|                          |     | channel.                                                                            |\n| REQUIRES_WORK_SELECTION  | 1   | If set to 1, the client notifies the server that it will send SetCustomMiningJob on |\n|                          |     | this connection                                                                     |\n| REQUIRES_VERSION_ROLLING | 2   | The client requires version rolling for efficiency or correct operation and the     |\n|                          |     | server MUST NOT send jobs which do not allow version rolling                        |\n\nFlags usable in `SetupConnection.Success.flags`:\n| Flag Name | Bit | Description |\n|----------------------------|-----|-----------------------------------------------------------------------------------|\n| REQUIRES_FIXED_VERSION | 0 | Upstream node will not accept any changes to the version field. Note that if |\n| | | REQUIRES_VERSION_ROLLING was set in the SetupConnection::flags field, this bit |\n| | | MUST NOT be set. Further, if this bit is set, extended jobs MUST NOT indicate |\n| | | support for version rolling. |\n| REQUIRES_EXTENDED_CHANNELS | 1 | Upstream node will not accept opening of a standard channel |\n\n### 5.3.2 `OpenStandardMiningChannel` (Client -> Server)\n\nThis message requests to open a standard channel to the upstream node.\n\nAfter receiving a `SetupConnection.Success` message, the client SHOULD respond by opening channels on the connection.\nIf no channels are opened within a reasonable period the server SHOULD close the connection for inactivity.\n\nEvery client SHOULD start its communication with an upstream node by opening a channel, which is necessary for almost all later communication.\nThe upstream node either passes opening the channel further or has enough local information to handle channel opening on its own (this is mainly intended for v1 proxies).\nClients must also communicate information about their hashing power in order to receive well-calibrated job assignments.\n\n| Field Name        | Data Type | Description                                                                                                                                                                                                                                                                                                                  |\n| ----------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| request_id        | U32       | Client-specified identifier for matching responses from upstream server. The value MUST be connection-wide unique and is not interpreted by the server.                                                                                                                                                                      |\n| user_identity     | STR0_255  | Unconstrained sequence of bytes. Whatever is needed by upstream node to identify/authenticate the client, e.g. \"braiinstest.worker1\". Additional restrictions can be imposed by the upstream node (e.g. a pool). It is highly recommended that UTF-8 encoding is used.                                                       |\n| nominal_hash_rate | F32       | [h/s] Expected hashrate of the device (or cumulative hashrate on the channel if multiple devices are connected downstream) in h/s. Depending on server's target setting policy, this value can be used for setting a reasonable target for the channel. Proxy MUST send 0.0f when there are no mining devices connected yet. |\n| max_target        | U256      | Maximum target which can be accepted by the connected device or devices. Server MUST accept the target or respond by sending OpenMiningChannel.Error message.                                                                                                                                                                |\n\n### 5.3.3 `OpenStandardMiningChannel.Success` (Server -> Client)\n\nSent as a response for opening a standard channel, if successful.\n\n| Field Name        | Data Type | Description                                                                                                                                                                    |\n| ----------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| request_id        | U32       | Client-specified request ID from OpenStandardMiningChannel message, so that the client can pair responses with open channel requests                                           |\n| channel_id        | U32       | Newly assigned identifier of the channel, stable for the whole lifetime of the connection, e.g. it is used for broadcasting new jobs by NewExtendedMiningJob                   |\n| target            | U256      | Initial target for the mining channel                                                                                                                                          |\n| extranonce_prefix | B0_32     | Bytes used as implicit first part of extranonce for the scenario when extended job is served by the upstream node for a set of standard channels that belong to the same group |\n| group_channel_id  | U32       | Group channel into which the new channel belongs. See SetGroupChannel for details.                                                                                             |\n\n### 5.3.4 `OpenExtendedMiningChannel` (Client -> Server)\n\nSimilar to [5.3.2 `OpenStandardMiningChannel`](#532-openstandardminingchannel-client---server), but requests to open an extended channel instead of standard channel.\n\n| Field Name                                    | Data Type | Description                                           |\n| --------------------------------------------- | --------- | ----------------------------------------------------- |\n| `<All fields from OpenStandardMiningChannel>` |\n| min_extranonce_size                           | U16       | Minimum size of extranonce needed by the device/node. |\n\n### 5.3.5 `OpenExtendedMiningChannel.Success` (Server -> Client)\n\nSent as a response for opening an extended channel.\n\n| Field Name        | Data Type | Description                                                                                                                                                  |\n| ----------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| request_id        | U32       | Client-specified request ID from OpenExtendedMiningChannel message, so that the client can pair responses with open channel requests                         |\n| channel_id        | U32       | Newly assigned identifier of the channel, stable for the whole lifetime of the connection, e.g. it is used for broadcasting new jobs by NewExtendedMiningJob |\n| target            | U256      | Initial target for the mining channel                                                                                                                        |\n| extranonce_size   | U16       | Extranonce size (in bytes) set for the channel                                                                                                               |\n| extranonce_prefix | B0_32     | Bytes used as implicit first part of extranonce                                                                                                              |\n\n### 5.3.6 `OpenMiningChannel.Error` (Server -> Client)\n\n| Field Name | Data Type | Description                                                 |\n| ---------- | --------- | ----------------------------------------------------------- |\n| request_id | U32       | Client-specified request ID from OpenMiningChannel message  |\n| error_code | STR0_255  | Human-readable error code(s), see Error Codes section below |\n\nPossible error codes:\n\n- `unknown-user`\n- `max-target-out-of-range`\n\n### 5.3.7 `UpdateChannel` (Client -> Server)\n\nClient notifies the server about changes on the specified channel.\nIf a client performs device/connection aggregation (i.e. it is a proxy), it MUST send this message when downstream channels change.\nThis update can be debounced so that it is not sent more often than once in a second (for a very busy proxy).\n\n| Field Name        | Data Type | Description                                                                                                                                                                                                                           |\n| ----------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id        | U32       | Channel identification                                                                                                                                                                                                                |\n| nominal_hash_rate | F32       | See Open\\*Channel for details                                                                                                                                                                                                         |\n| maximum_target    | U256      | Maximum target is changed by server by sending SetTarget. This field is understood as device's request. There can be some delay between UpdateChannel and corresponding SetTarget messages, based on new job readiness on the server. |\n\nWhen `maximum_target` is smaller than currently used maximum target for the channel, upstream node MUST reflect the client’s request (and send appropriate `SetTarget` message).\n\n### 5.3.8 `UpdateChannel.Error` (Server -> Client)\n\nSent only when `UpdateChannel` message is invalid. When it is accepted by the server, no response is sent back.\n\n| Field Name | Data Type | Description                                                 |\n| ---------- | --------- | ----------------------------------------------------------- |\n| channel_id | U32       | Channel identification                                      |\n| error_code | STR0_255  | Human-readable error code(s), see Error Codes section below |\n\nPossible error codes:\n\n- `max-target-out-of-range`\n- `invalid-channel-id`\n\n### 5.3.9 `CloseChannel` (Client -> Server, Server -> Client)\n\nClient sends this message when it ends its operation.\nThe server MUST stop sending messages for the channel.\nA proxy MUST send this message on behalf of all opened channels from a downstream connection in case of downstream connection closure.\n\n| Field Name  | Data Type | Description                    |\n| ----------- | --------- | ------------------------------ |\n| channel_id  | U32       | Channel identification         |\n| reason_code | STR0_255  | Reason for closing the channel |\n\nIf a proxy is operating in channel aggregating mode (translating downstream channels into aggregated extended upstream channels), it MUST send an `UpdateChannel` message when it receives `CloseChannel` or connection closure from a downstream connection.\nIn general, proxy servers MUST keep the upstream node notified about the real state of the downstream channels.\n\n### 5.3.10 `SetExtranoncePrefix` (Server -> Client)\n\nChanges downstream node’s extranonce prefix.\nIt is applicable for all jobs sent after this message on a given channel (both jobs provided by the upstream or jobs introduced by `SetCustomMiningJob` message).\nThis message is applicable only for explicitly opened extended channels or standard channels (not group channels).\n\n| Field Name        | Data Type | Description                                     |\n| ----------------- | --------- | ----------------------------------------------- |\n| channel_id        | U32       | Extended or standard channel identifier         |\n| extranonce_prefix | B0_32     | Bytes used as implicit first part of extranonce |\n\n### 5.3.11 `SubmitSharesStandard` (Client -> Server)\n\nClient sends result of its hashing work to the server.\n\n| Field Name      | Data Type | Description                                                                                                                                                                                                                                    |\n| --------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id      | U32       | Channel identification                                                                                                                                                                                                                         |\n| sequence_number | U32       | Unique sequential identifier of the submit within the channel                                                                                                                                                                                  |\n| job_id          | U32       | Identifier of the job as provided by NewMiningJob or NewExtendedMiningJob message                                                                                                                                                              |\n| nonce           | U32       | Nonce leading to the hash being submitted                                                                                                                                                                                                      |\n| ntime           | U32       | The nTime field in the block header. This MUST be greater than or equal to the header_timestamp field in the latest SetNewPrevHash message and lower than or equal to that value plus the number of seconds since the receipt of that message. |\n| version         | U32       | Full nVersion field                                                                                                                                                                                                                            |\n\n### 5.3.12 `SubmitSharesExtended` (Client -> Server)\n\nOnly relevant for extended channels.\nThe message is the same as `SubmitShares`, with the following additional field:\n\n| Field Name                              | Data Type | Description                                                                                                                                                                                                                                                                                |\n| --------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `<SubmitSharesStandard message fields>` |\n| extranonce                              | B0_32     | Extranonce bytes which need to be added to coinbase to form a fully valid submission (full coinbase = coinbase_tx_prefix + extranonce_prefix + extranonce + coinbase_tx_suffix). The size of the provided extranonce MUST be equal to the negotiated extranonce size from channel opening. |\n\n### 5.3.13 `SubmitShares.Success` (Server -> Client)\n\nResponse to `SubmitShares` or `SubmitSharesExtended`, accepting results from the miner.\nBecause it is a common case that shares submission is successful, this response can be provided for multiple `SubmitShare` messages aggregated together.\n\n| Field Name                 | Data Type | Description                                         |\n| -------------------------- | --------- | --------------------------------------------------- |\n| channel_id                 | U32       | Channel identification                              |\n| last_sequence_number       | U32       | Most recent sequence number with a correct result   |\n| new_submits_accepted_count | U32       | Count of new submits acknowledged within this batch |\n| new_shares_sum             | U64       | Sum of shares acknowledged within this batch        |\n\nThe server does not have to double check that the sequence numbers sent by a client are actually increasing.\nIt can simply use the last one received when sending a response.\nIt is the client’s responsibility to keep the sequence numbers correct/useful.\n\n### 5.3.14 `SubmitShares.Error` (Server -> Client)\n\nAn error is immediately submitted for every incorrect submit attempt.\nIn case the server is not able to immediately validate the submission, the error is sent as soon as the result is known.\nThis delayed validation can occur when a miner gets faster updates about a new prevhash than the server does (see `NewPrevHash` message for details).\n\n| Field Name      | Data Type | Description                                                 |\n| --------------- | --------- | ----------------------------------------------------------- |\n| channel_id      | U32       | Channel identifier                                          |\n| sequence_number | U32       | Submission sequence number for which this error is returned |\n| error_code      | STR0_255  | Human-readable error code(s), see Error Codes section below |\n\nPossible error codes:\n\n- `invalid-channel-id`\n- `stale-share`\n- `difficulty-too-low`\n- `invalid-job-id`\n\n### 5.3.15 `NewMiningJob` (Server -> Client)\n\nThe server provides an updated mining job to the client through a standard channel. This MUST be the first message after the channel has been successfully opened. This first message will have min_ntime unset (future job).\n\nIf the `min_ntime` field is set, the client MUST start to mine on the new job immediately after receiving this message, and use the value for the initial nTime.\n\n| Field Name  | Data Type   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ----------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id  | U32         | Channel identifier, this must be a standard channel                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| job_id      | U32         | Identifier of the job as provided by NewMiningJob or NewExtendedMiningJob message                                                                                                                                                                                                                                                                                                                                                                                                   |\n| min_ntime   | OPTION[u32] | Smallest nTime value available for hashing for the new mining job. An empty value indicates this is a future job to be activated once a SetNewPrevHash message is received with a matching job_id. This SetNewPrevHash message provides the new prev_hash and min_ntime. If the min_ntime value is set, this mining job is active and miner must start mining on it immediately. In this case, the new mining job uses the prev_hash from the last received SetNewPrevHash message. |\n| version     | U32         | Valid version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value.                                                                                                                                                                                                         |\n| merkle_root | U256         | Merkle root field as used in the bitcoin block header                                                                                                                                                                                                                                                                                                                                                                                                                              |\n\n### 5.3.16 `NewExtendedMiningJob` (Server -> Client)\n\n(Extended and group channels only)\n\nFor an **extended channel**:\nThe whole search space of the job is owned by the specified channel.\nIf the `min_ntime` field is set to some nTime, the client MUST start to mine on the new job as soon as possible after receiving this message.\n\nFor a **group channel**:\nThis is a broadcast variant of `NewMiningJob` message with the `merkle_root` field replaced by `merkle_path` and coinbase transaction prefix and suffix, for further traffic optimization.\nThe Merkle root is then defined deterministically for each channel by the common `merkle_path` and unique `extranonce_prefix` serialized into the coinbase.\nThe full coinbase is then constructed as follows: `coinbase_tx_prefix + extranonce_prefix + coinbase_tx_suffix`.\n\nThe proxy MAY transform this multicast variant for downstream standard channels into `NewMiningJob` messages by computing the derived Merkle root for them.\nA proxy MUST translate the message for all downstream channels belonging to the group which don’t signal that they accept extended mining jobs in the `SetupConnection` message (intended and expected behavior for end mining devices).\n\n| Field Name              | Data Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| ----------------------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| channel_id              | U32            | For a group channel, the message is broadcasted to all standard channels belonging to the group. Otherwise, it is addressed to the specified extended channel.                                                                                                                                                                                                                                                                                                                                   |\n| job_id                  | U32            | Server’s identification of the mining job                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| min_ntime               | OPTION[u32]    | Smallest nTime value available for hashing for the new mining job. An empty value indicates this is a future job to be activated once a SetNewPrevHash message is received with a matching job_id. This SetNewPrevHash message provides the new prev_hash and min_ntime. If the min_ntime value is set, this mining job is active and miner must start mining on it immediately. In this case, the new mining job uses the prev_hash from the last received SetNewPrevHash message. immediately. |\n| version                 | U32            | Valid version field that reflects the current network consensus                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| version_rolling_allowed | BOOL           | If set to True, the general purpose bits of version (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value. If set to False, the downstream node MUST use version as it is defined by this message.                                                                                                                                                                    |\n| merkle_path             | SEQ0_255[U256] | Merkle path hashes ordered from deepest                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| coinbase_tx_prefix      | B0_64K         | Prefix part of the coinbase transaction\\*                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| coinbase_tx_suffix      | B0_64K         | Suffix part of the coinbase transaction                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\n\\*The full coinbase is constructed by inserting one of the following:\n\n- For a **standard channel**: `extranonce_prefix`\n- For an **extended channel**: `extranonce_prefix + extranonce (=N bytes)`, where `N` is the negotiated extranonce space for the channel (`OpenMiningChannel.Success.extranonce_size`)\n\n### 5.3.17 `SetNewPrevHash` (Server -> Client, broadcast)\n\nPrevhash is distributed whenever a new block is detected in the network by an upstream node or when a new downstream opens a channel.\n\nThis message MAY be shared by all downstream nodes (sent only once to each channel group).\nClients MUST immediately start to mine on the provided prevhash.\nWhen a client receives this message, only the job referenced by Job ID is valid.\nThe remaining jobs already queued by the client have to be made invalid.\n\nNote: There is no need for block height in this message.\n\n| Field Name | Data Type | Description                                                                                                                                                                                                                                                                |\n| ---------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id | U32       | Group channel or channel that this prevhash is valid for                                                                                                                                                                                                                   |\n| job_id     | U32       | ID of a job that is to be used for mining with this prevhash. A pool may have provided multiple jobs for the next block height (e.g. an empty block or a block with transactions that are complementary to the set of transactions present in the current block template). |\n| prev_hash  | U256      | Previous block’s hash, block header field                                                                                                                                                                                                                                  |\n| min_ntime  | U32       | Smallest nTime value available for hashing                                                                                                                                                                                                                                 |\n| nbits      | U32       | Block header field                                                                                                                                                                                                                                                         |\n\n### 5.3.18 `SetCustomMiningJob` (Client -> Server)\n\nCan be sent only on extended channel.\n`SetupConnection.flags` MUST contain `REQUIRES_WORK_SELECTION` flag (work selection feature successfully declared).\n\nThe downstream node has a custom job declared by a trusted external Job Declarator.\nThe `mining_job_token` provides the information for the pool to authorize the custom job that has been or will be declared between the Job Declarator and Pool.\n\n| Field Name                  | Data Type      | Description                                                                                                                                                           |\n| --------------------------- | -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id                  | U32            | Extended channel identifier                                                                                                                                           |\n| request_id                  | U32            | Client-specified identifier for pairing responses                                                                                                                     |\n| mining_job_token            | B0_255         | Token provided by JDS which uniquely identifies the Custom Job that JDC has declared. See the Job Declaration Protocol for more details.                              |\n| version                     | U32            | Valid version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node.  |\n| prev_hash                   | U256           | Previous block’s hash, found in the block header field                                                                                                                |\n| min_ntime                   | U32            | Smallest nTime value available for hashing                                                                                                                            |\n| nbits                       | U32            | Block header field                                                                                                                                                    |\n| coinbase_tx_version         | U32            | The coinbase transaction nVersion field                                                                                                                               |\n| coinbase_prefix             | B0_255         | Up to 8 bytes (not including the length byte) which are to be placed at the beginning of the coinbase field in the coinbase transaction.                              |\n| coinbase_tx_input_nSequence | U32            | The coinbase transaction input's nSequence field                                                                                                                      |\n| coinbase_tx_value_remaining | U64            | The value, in satoshis, available for spending in coinbase outputs added by the client. Includes both transaction fees and block subsidy.                             |\n| coinbase_tx_outputs         | B0_64K         | Bitcoin transaction outputs to be included as the last outputs in the coinbase transaction                                                                            |\n| coinbase_tx_locktime        | U32            | The locktime field in the coinbase transaction                                                                                                                        |\n| merkle_path                 | SEQ0_255[U256] | Merkle path hashes ordered from deepest                                                                                                                               |\n\n### 5.3.19 `SetCustomMiningJob.Success` (Server -> Client)\n\nResponse from the Pool when it accepts the custom mining job.\n\nUp until receiving this message (and after having all the necessary information to start hashing), the miner SHOULD start hashing and buffer the work optimistically.\n\nThis message acts as a commitment from the Pool to rewarding this job. In case the Pool does not commit (either by timeout, or responding with `SetCustomMiningJob.Error`), the miner SHOULD fall back to a different Pool (or solo).\n\nAfter receiving it, the miner can start submitting shares for this job immediately (by using the `job_id` provided within this response).\n\n| Field Name         | Data Type | Description                                                               |\n| ------------------ | --------- | ------------------------------------------------------------------------- |\n| channel_id         | U32       | Extended channel identifier                                               |\n| request_id         | U32       | Client-specified identifier for pairing responses. Value from the request |\n|                    |           | MUST be provided by upstream in the response message.                     |\n| job_id             | U32       | Server’s identification of the mining job                                 |\n\n\\*The full coinbase is constructed by inserting one of the following:\n\n- For a **standard channel**: `extranonce_prefix`\n- For an **extended channel**: `extranonce_prefix + extranonce (=N bytes)`, where `N` is the negotiated extranonce space for the channel (`OpenMiningChannel.Success.extranonce_size`)\n\n### 5.3.20 `SetCustomMiningJob.Error` (Server -> Client)\n\n| Field Name | Data Type | Description                                                                                                                     |\n| ---------- | --------- | ------------------------------------------------------------------------------------------------------------------------------- |\n| channel_id | U32       | Extended channel identifier                                                                                                     |\n| request_id | U32       | Client-specified identifier for pairing responses. Value from the request MUST be provided by upstream in the response message. |\n| error_code | STR0_255  | Reason why the custom job has been rejected                                                                                     |\n\nPossible errors:\n\n- `invalid-channel-id`\n- `invalid-mining-job-token`\n- `invalid-job-param-value-{}` - `{}` is replaced by a particular field name from `SetCustomMiningJob` message\n\n### 5.3.21 `SetTarget` (Server -> Client)\n\nThe server controls the submission rate by adjusting the difficulty target on a specified channel.\nAll submits leading to hashes higher than the specified target will be rejected by the server.\n\nMaximum target is valid until the next `SetTarget` message is sent and is applicable for all jobs received on the channel in the future or already received with an empty `min_ntime`.\nThe message is not applicable for already received jobs with `min_ntime=nTime`, as their maximum target remains stable.\n\n| Field Name     | Data Type | Description                                                                       |\n| -------------- | --------- | --------------------------------------------------------------------------------- |\n| channel_id     | U32       | Channel identifier                                                                |\n| maximum_target | U256      | Maximum value of produced hash that will be accepted by a server to accept shares |\n\nWhen `SetTarget` is sent to a group channel, the maximum target is applicable to all channels in the group.\n\n\n### 5.3.22 `SetGroupChannel` (Server -> Client)\n\nEvery standard channel is a member of a group of standard channels, addressed by the upstream server's provided identifier.\nThe group channel is used mainly for efficient job distribution to multiple standard channels at once.\n\nIf we want to allow different jobs to be served to different standard channels (e.g. because of different [BIP 8](https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki) version bits) and still be able to distribute the work by sending `NewExtendendedMiningJob` instead of a repeated `NewMiningJob`, we need a more fine-grained grouping for standard channels.\n\nThis message associates a set of standard channels with a group channel.\nA channel (identified by particular ID) becomes a group channel when it is used by this message as `group_channel_id`.\nThe server MUST ensure that a group channel has a unique channel ID within one connection. Channel reinterpretation is not allowed.\n\nThis message can be sent only to connections that don’t have `REQUIRES_STANDARD_JOBS` flag in `SetupConnection`.\n\n| Field Name       | Data Type     | Description                                                                               |\n| ---------------- | ------------- | ----------------------------------------------------------------------------------------- |\n| group_channel_id | U32           | Identifier of the group where the standard channel belongs                                |\n| channel_ids      | SEQ0_64K[U32] | A sequence of opened standard channel IDs, for which the group channel is being redefined |\n",
    "html": "<h1>5. Mining Protocol</h1>\n<p>The Mining Protocol enables the distribution of work to mining devices and the submission of proof-of-work results.</p>\n<p>It can be used without Job Declaration and Template Distribution Protocols, where a subset of the messages are used by a pool to unilaterally distribute work to miners.</p>\n<p>Alternatively, it can be used in conjunction with Job Declaration and Template Distribution Protocols, where both pool and miners coordinate to decide what is valid work.</p>\n<h2>5.1 Job</h2>\n<p>A <strong>Job</strong> consists of a unit of work containing all the necessary information about the hashing space over some candidate block header.</p>\n<p>Each Mining Device has to work on a unique part of the whole search space.\nThe full search space is defined in part by valid values in the following block header fields:</p>\n<ul>\n<li><code>nonce</code> header field (32 bits)</li>\n<li><code>version</code> header field (16 bits, as specified by <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0320.mediawiki\">BIP 320</a>)</li>\n<li><code>nTime</code> header field (32 bits timestamp, limited under <a href=\"https://github.com/bitcoin/bitcoin/blob/28ce159bc327e6dfec34077ff2e379b23a95db65/src/chain.h#L29\"><code>MAX_FUTURE_BLOCK_TIME</code></a>)</li>\n</ul>\n<p>The other portion of the block header that is used to define the full search space is the Merkle Root, which is deterministically computed from:</p>\n<ul>\n<li>Coinbase transaction</li>\n<li>Transaction set</li>\n</ul>\n<p>All roles in Stratum v2 MUST NOT use transaction selection/ordering for additional hash space extension.\nThis stems both from the concept that miners/pools should be able to choose their transaction set freely without any interference with the protocol, and also to enable future protocol modifications to Bitcoin.\nIn other words, any rules imposed on transaction selection/ordering by miners not described in the rest of this document may result in invalid work.</p>\n<p>Mining servers MUST assign a unique subset of the search space to each mining device, otherwise the mining devices will waste energy with overlapping search.</p>\n<p>This protocol explicitly expects that upstream server software is able to manage the size of the hashing space correctly for its clients and can provide new and unique Jobs quickly enough, based on the hashpower of each client.</p>\n<p>The protocol defines two main types of Jobs: <strong>Standard Job</strong> and <strong>Extended Job</strong>.</p>\n<p>This separation vastly simplifies the protocol implementation for clients that don’t support Extended Job, as they only need to implement the subset of protocol messages related to Standard Job (see Mining Protocol Messages for details).</p>\n<p>Additionally, a Job (either Standard or Extended) also could be potentially labeled as a <strong>Future Job</strong> and/or <strong>Custom Job</strong>.</p>\n<h3>5.1.1 Standard Job</h3>\n<p>Standard Jobs are restricted to fixed Merkle Roots, where the only modifiable bits are under the <code>version</code>, <code>nonce</code>, and <code>nTime</code> fields of the block header.</p>\n<p>We call this header-only mining (HOM), and it is the smallest assignable unit of search space by the protocol.</p>\n<p>The size of the search space for one Standard Job, given a fixed <code>nTime</code> field, is <code>2^(NONCE_BITS + BIP320_VERSION_ROLLING_BITS) = ~280Th</code>, where <code>NONCE_BITS = 32</code> and <code>BIP320_VERSION_ROLLING_BITS = 16</code>.\nThis is a guaranteed space before <code>nTime</code> rolling (or changing the Merkle Root by sending a new Job).</p>\n<p>Standard Jobs are distributed via the <a href=\"#5315-newminingjob-server---client\"><code>NewMiningJob</code></a> message, which can ONLY be sent via <a href=\"#521-standard-channels\">Standard Channels</a>.</p>\n<p>Note that Mining Devices with hashrate above 280 TH/s will outrun the true time when rolling the <code>nTime</code> field. This is not necessarily a problem, as long as the Job remains valid within the limits defined by the <code>MAX_FUTURE_BLOCK_TIME</code> constant of the Bitcoin protocol (2 hours).</p>\n<p>Depending on the hashrate of the Mining Device, it must receive new Standard Jobs (with a different Merkle Root) frequently enough in order to avoid rolling <code>nTime</code> too much ahead of the true time (which could result in rejected work).</p>\n<p><img src=\"./img/standard_job.png\" alt=\"\"></p>\n<h3>5.1.2 Extended Job</h3>\n<p>Extended Jobs allow rolling Merkle Roots, giving extensive control over the search space so that they can implement various advanced use cases such as:</p>\n<ul>\n<li>translation between Sv1 and Sv2 protocols</li>\n<li>difficulty aggregation</li>\n<li>search space splitting</li>\n</ul>\n<p>Extended Jobs are distributed via the <a href=\"#5416-newextendedminingjob-server---client\"><code>NewExtendedMiningJob</code></a> message, which can be sent via:</p>\n<ul>\n<li><a href=\"#523-group-channels\">Group Channels</a></li>\n<li><a href=\"#522-extended-channels\">Extended Channels</a></li>\n</ul>\n<p><img src=\"./img/extended_job.png\" alt=\"\"></p>\n<h4>5.1.2.1 Extended Extranonce</h4>\n<p>Downstream and Upstream are relative terms. There could theoretically be multiple nested layers of Stratum Nodes (e.g.: Proxies) between a Work-Providing Node and a Mining Device.</p>\n<p>So the protocol establishes the notion of <strong>Extended Extranonce</strong>, which is a fundamental component of Extended Jobs.</p>\n<p>The Extended Extranonce is an array of bytes, split into three different areas:</p>\n<p><img src=\"./img/extended_extranonce.png\" alt=\"\"></p>\n<ul>\n<li>The <code>extranonce_prefix</code> bytes are reserved for the upstream layer, where fixed bytes were already established for the Extranonce and are no longer available for rolling or search space splitting.</li>\n<li>The <strong>locally reserved</strong> bytes is where the local layer will assign unique values for its own downstream clients, according to their hashpower.</li>\n<li>The <strong>downstream reserved</strong> bytes is where the downstream clients will further distribute the search space, or use for rolling (if they are Mining Devices).</li>\n</ul>\n<p><img src=\"./img/extended_extranonce_layers.png\" alt=\"\"></p>\n<p>In order to calculate the Merkle Root, an Extended Job carries the following data:</p>\n<ul>\n<li><code>merkle_path</code></li>\n<li><code>coinbase_tx_prefix</code></li>\n<li><code>coinbase_tx_suffix</code></li>\n</ul>\n<p>An <a href=\"#532-extended-channels\">Extended Channel</a> has the following properties:</p>\n<ul>\n<li><code>extranonce_prefix</code>: the Extended Extranonce bytes that were already allocated by the upstream server.</li>\n<li><code>extranonce_size</code>: how many bytes are available for the locally reserved and downstream reserved areas of the Extended Extranonce.</li>\n</ul>\n<p>And a <a href=\"#531-standard-channels\">Standard Channel</a> has the following property:</p>\n<ul>\n<li><code>extranonce_prefix</code> the Extended Extranonce bytes that were already allocated by the upstream server.</li>\n</ul>\n<p>So when some layer receives an Extended Job, it could either:</p>\n<ul>\n<li>propagate it as an Extended Job to a downstream Extended or Group Channel (via <code>NewExtendedMiningJob</code> notification), where the Extended Extranonce will be further split.</li>\n<li>convert it into multiple Standard Job notifications (<code>NewMiningJob</code>), where each downstream Standard Channel’s <code>extranonce_prefix</code> is combined with <code>coinbase_tx_prefix</code> + <code>coinbase_tx_suffix</code>.</li>\n</ul>\n<p>For conversion into Standard Jobs, the Coinbase Transaction is constructed by concatenating these fields in this specific order: <code>coinbase_tx_prefix + extranonce_prefix + coinbase_tx_suffix</code>.</p>\n<p>The Coinbase Transaction is then combined with the <code>merkle_path</code> of the Extended Job to calculate the <code>merkle_root</code> for the Standard Job notification (<code>NewMiningJob</code>). Since Standard Jobs are HOM, there’s no <code>extranonce_size</code> field on the Standard Job notification.</p>\n<h3>5.1.3 Future Job</h3>\n<p>A Job with an empty template or speculated non-empty template can be sent in advance to speedup Job distribution when a new block is found on the network.</p>\n<p>The mining server MAY have precomputed such a Job and is able to pre-distribute it for all active Channels.\nThe only missing information to start to mine on the new block is the new <code>prev_hash</code>.\nThis information can be provided independently.</p>\n<p>Such an approach improves the efficiency of the protocol where the upstream node does not waste precious time immediately after a new block is found in the network.</p>\n<p>The trade-off here is that a non-empty Future Job could potentially contain a transaction that was already included in the block that was just propagated on the network, which would lead to an invalid block if successfully mined.</p>\n<p>So mining servers that provide non-empty Future Jobs SHOULD:</p>\n<ul>\n<li>never send a <code>SetNewPrevHash</code> for a Future Job that was later found to contain a conflicting transaction.</li>\n<li>minimize the probability of Future Jobs containing conflicting transactions (which leads to Future Jobs carrying less profitable templates).</li>\n<li>after a <code>SetNewPrevHash</code> is propagated for a Future Job, provide a non-Future Job for this same <code>prev_hash</code> as fast as possible (with a more profitable template).</li>\n</ul>\n<h3>5.1.4 Custom Job</h3>\n<p>A Custom Job contains a set of transactions that were chosen by the miner instead of being unilaterally imposed by the Pool.</p>\n<p>Under the Job Declaration Protocol, upon request the Job Declarator Server (JDS) sends a <code>mining_job_token</code> to the Job Declarator Client.</p>\n<p>This <code>mining_job_token</code> is used by JDC for:</p>\n<ul>\n<li>declaring a Custom Job to JDS (via <code>DeclareMiningJob</code> message of Job Declaration Protocol)</li>\n<li>notifying Pool about a Custom Job (via <code>SetCustomMiningJob</code> message of Mining Protocol)</li>\n</ul>\n<p>This is a key feature of Stratum V2 that improves Bitcoin decentralization. Please see Job Declaration Protocol for more details.</p>\n<h2>5.2 Channel</h2>\n<p>The Mining Protocol is designed such that downstream Mining Devices open Channels with upstream Stratum Nodes within established Connections.\nThese upstream Stratum Nodes could be actual Work-Providing Nodes (e.g.: Pool, or Job Declarator Client) or simply Proxies that relay messages forward.</p>\n<p>Each Channel identifies a dedicated mining session associated with an authorized user.\nUpstream stratum nodes accept work submissions and specify a mining target on a per-channel basis.</p>\n<p>There can theoretically be up to <code>2^32</code> open Channels within one Connection. This is however just a theoretical ceiling, and it does not mean that every Connection will be able to fill this full capacity (maybe the search space has already been narrowed).</p>\n<p>All Channels are independent of each other, but share some messages broadcast from the server for higher efficiency (e.g. information about a new <code>prev_hash</code>).\nEach Channel is identified by its <code>channel_id</code> (<code>U32</code>), which is consistent throughout the whole life of the Connection. There MUST NOT be two Channels with the same ID in the same Connection.</p>\n<p>A Proxy can either transparently allow its clients to open separate Channels with the server (preferred behavior), or aggregate open connections from downstream devices into its own open channel with the server and translate the messages accordingly (present mainly for allowing v1 proxies).\nBoth options have some practical use cases.\nIn either case, proxies SHOULD aggregate clients’ Channels into a smaller number of Connections.\nThis saves network traffic for broadcast messages sent by a server because fewer messages need to be sent in total, which leads to lower latencies as a result.\nAnd it further increases efficiency by allowing larger packets to be sent.</p>\n<p>The protocol defines three types of Channels: <strong>Standard Channel</strong>, <strong>Extended Channel</strong> and <strong>Group Channel</strong>, which are useful for different purposes.</p>\n<h3>5.2.1 Standard Channel</h3>\n<p>Standard Channels are created by end Mining Devices.</p>\n<p>When an end Mining Device opens a Standard Channel with an upstream, it is restricted to Standard Jobs (via <code>REQUIRES_STANDARD_JOBS</code> bit flag of <code>SetupConnection</code> message).</p>\n<p>However, a Proxy could also transparently relay the Standard Channels from the downstream Mining Devices into new upstream Connections. In this case, the <code>REQUIRES_STANDARD_JOBS</code> bit flag will not be set for the <code>SetupConnection</code> message. This indicates that on this Connection, the Standard Channels can be assembled into a Group Channel and receive Extended Jobs for efficient distribution downstream.</p>\n<p>Then, the Connections between the Proxy and Mining Devices will receive Standard Jobs that were efficiently distributed from the Extended Jobs. The Merkle Root of each Standard Job is calculated by the Proxy, taking in consideration the <code>extranonce_prefix</code> that was assigned to each Standard Channel, plus the <code>coinbase_tx_prefix</code> and the <code>coinbase_tx_suffix</code> that were sent on the Extended Job. No <code>extranonce</code> field is used in this scenario.</p>\n<h3>5.2.2 Extended Channel</h3>\n<p>Extended Channels are intended to be used by Proxies for a more efficient distribution of hashing space.</p>\n<p>An Extended Channel carries the following properties:</p>\n<ul>\n<li><code>extranonce_prefix</code>: the Extended Extranonce bytes that were already allocated by the upstream server.</li>\n<li><code>extranonce_size</code>: how many bytes are available for the locally reserved and downstream reserved areas of the Extended Extranonce.</li>\n</ul>\n<p>Upstream servers which accept connections and provide work MUST support Extended Channels.\nClients, on the other hand, do not have to support Extended Channels, as they MAY be implemented more simply with only Standard Channels at the end-device level.\nThus, upstream servers providing work MUST also support Standard Channels.</p>\n<p>The size of search space for an Extended Channel is <code>2^(nonce_bits + version_rolling_bits + extranonce_size*8)</code> per <code>nTime</code> value.</p>\n<h3>5.2.3 Group Channel</h3>\n<p>Standard channels opened within one particular connection can be grouped together to be addressable by a common communication group channel.</p>\n<p>Whenever a Standard Channel is created, it is always put into some Group Channel identified by its <code>group_channel_id</code>.\nGroup Channel ID namespace is the same as Standard Channel ID namespace on a particular connection.</p>\n<h2>5.3 Mining Protocol Messages</h2>\n<h3>5.3.1 <code>SetupConnection</code> Flags for Mining Protocol</h3>\n<p>Flags usable in <code>SetupConnection.flags</code> and <code>SetupConnection.Error::flags</code>, where bit 0 is the least significant bit of the u32 type:</p>\n<table>\n<thead>\n<tr>\n<th>Flag Name</th>\n<th>Bit</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>REQUIRES_STANDARD_JOBS</td>\n<td>0</td>\n<td>The downstream node requires standard jobs. It does not understand group channels -</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>it is unable to process extended jobs sent to standard channels through a group</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>channel.</td>\n</tr>\n<tr>\n<td>REQUIRES_WORK_SELECTION</td>\n<td>1</td>\n<td>If set to 1, the client notifies the server that it will send SetCustomMiningJob on</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>this connection</td>\n</tr>\n<tr>\n<td>REQUIRES_VERSION_ROLLING</td>\n<td>2</td>\n<td>The client requires version rolling for efficiency or correct operation and the</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>server MUST NOT send jobs which do not allow version rolling</td>\n</tr>\n</tbody>\n</table>\n<p>Flags usable in <code>SetupConnection.Success.flags</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Flag Name</th>\n<th>Bit</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>REQUIRES_FIXED_VERSION</td>\n<td>0</td>\n<td>Upstream node will not accept any changes to the version field. Note that if</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>REQUIRES_VERSION_ROLLING was set in the SetupConnection::flags field, this bit</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>MUST NOT be set. Further, if this bit is set, extended jobs MUST NOT indicate</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>support for version rolling.</td>\n</tr>\n<tr>\n<td>REQUIRES_EXTENDED_CHANNELS</td>\n<td>1</td>\n<td>Upstream node will not accept opening of a standard channel</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.2 <code>OpenStandardMiningChannel</code> (Client -&gt; Server)</h3>\n<p>This message requests to open a standard channel to the upstream node.</p>\n<p>After receiving a <code>SetupConnection.Success</code> message, the client SHOULD respond by opening channels on the connection.\nIf no channels are opened within a reasonable period the server SHOULD close the connection for inactivity.</p>\n<p>Every client SHOULD start its communication with an upstream node by opening a channel, which is necessary for almost all later communication.\nThe upstream node either passes opening the channel further or has enough local information to handle channel opening on its own (this is mainly intended for v1 proxies).\nClients must also communicate information about their hashing power in order to receive well-calibrated job assignments.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified identifier for matching responses from upstream server. The value MUST be connection-wide unique and is not interpreted by the server.</td>\n</tr>\n<tr>\n<td>user_identity</td>\n<td>STR0_255</td>\n<td>Unconstrained sequence of bytes. Whatever is needed by upstream node to identify/authenticate the client, e.g. “braiinstest.worker1”. Additional restrictions can be imposed by the upstream node (e.g. a pool). It is highly recommended that UTF-8 encoding is used.</td>\n</tr>\n<tr>\n<td>nominal_hash_rate</td>\n<td>F32</td>\n<td>[h/s] Expected hashrate of the device (or cumulative hashrate on the channel if multiple devices are connected downstream) in h/s. Depending on server’s target setting policy, this value can be used for setting a reasonable target for the channel. Proxy MUST send 0.0f when there are no mining devices connected yet.</td>\n</tr>\n<tr>\n<td>max_target</td>\n<td>U256</td>\n<td>Maximum target which can be accepted by the connected device or devices. Server MUST accept the target or respond by sending OpenMiningChannel.Error message.</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.3 <code>OpenStandardMiningChannel.Success</code> (Server -&gt; Client)</h3>\n<p>Sent as a response for opening a standard channel, if successful.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified request ID from OpenStandardMiningChannel message, so that the client can pair responses with open channel requests</td>\n</tr>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Newly assigned identifier of the channel, stable for the whole lifetime of the connection, e.g. it is used for broadcasting new jobs by NewExtendedMiningJob</td>\n</tr>\n<tr>\n<td>target</td>\n<td>U256</td>\n<td>Initial target for the mining channel</td>\n</tr>\n<tr>\n<td>extranonce_prefix</td>\n<td>B0_32</td>\n<td>Bytes used as implicit first part of extranonce for the scenario when extended job is served by the upstream node for a set of standard channels that belong to the same group</td>\n</tr>\n<tr>\n<td>group_channel_id</td>\n<td>U32</td>\n<td>Group channel into which the new channel belongs. See SetGroupChannel for details.</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.4 <code>OpenExtendedMiningChannel</code> (Client -&gt; Server)</h3>\n<p>Similar to <a href=\"#532-openstandardminingchannel-client---server\">5.3.2 <code>OpenStandardMiningChannel</code></a>, but requests to open an extended channel instead of standard channel.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;All fields from OpenStandardMiningChannel&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>min_extranonce_size</td>\n<td>U16</td>\n<td>Minimum size of extranonce needed by the device/node.</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.5 <code>OpenExtendedMiningChannel.Success</code> (Server -&gt; Client)</h3>\n<p>Sent as a response for opening an extended channel.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified request ID from OpenExtendedMiningChannel message, so that the client can pair responses with open channel requests</td>\n</tr>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Newly assigned identifier of the channel, stable for the whole lifetime of the connection, e.g. it is used for broadcasting new jobs by NewExtendedMiningJob</td>\n</tr>\n<tr>\n<td>target</td>\n<td>U256</td>\n<td>Initial target for the mining channel</td>\n</tr>\n<tr>\n<td>extranonce_size</td>\n<td>U16</td>\n<td>Extranonce size (in bytes) set for the channel</td>\n</tr>\n<tr>\n<td>extranonce_prefix</td>\n<td>B0_32</td>\n<td>Bytes used as implicit first part of extranonce</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.6 <code>OpenMiningChannel.Error</code> (Server -&gt; Client)</h3>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified request ID from OpenMiningChannel message</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Human-readable error code(s), see Error Codes section below</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>unknown-user</code></li>\n<li><code>max-target-out-of-range</code></li>\n</ul>\n<h3>5.3.7 <code>UpdateChannel</code> (Client -&gt; Server)</h3>\n<p>Client notifies the server about changes on the specified channel.\nIf a client performs device/connection aggregation (i.e. it is a proxy), it MUST send this message when downstream channels change.\nThis update can be debounced so that it is not sent more often than once in a second (for a very busy proxy).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identification</td>\n</tr>\n<tr>\n<td>nominal_hash_rate</td>\n<td>F32</td>\n<td>See Open*Channel for details</td>\n</tr>\n<tr>\n<td>maximum_target</td>\n<td>U256</td>\n<td>Maximum target is changed by server by sending SetTarget. This field is understood as device’s request. There can be some delay between UpdateChannel and corresponding SetTarget messages, based on new job readiness on the server.</td>\n</tr>\n</tbody>\n</table>\n<p>When <code>maximum_target</code> is smaller than currently used maximum target for the channel, upstream node MUST reflect the client’s request (and send appropriate <code>SetTarget</code> message).</p>\n<h3>5.3.8 <code>UpdateChannel.Error</code> (Server -&gt; Client)</h3>\n<p>Sent only when <code>UpdateChannel</code> message is invalid. When it is accepted by the server, no response is sent back.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identification</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Human-readable error code(s), see Error Codes section below</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>max-target-out-of-range</code></li>\n<li><code>invalid-channel-id</code></li>\n</ul>\n<h3>5.3.9 <code>CloseChannel</code> (Client -&gt; Server, Server -&gt; Client)</h3>\n<p>Client sends this message when it ends its operation.\nThe server MUST stop sending messages for the channel.\nA proxy MUST send this message on behalf of all opened channels from a downstream connection in case of downstream connection closure.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identification</td>\n</tr>\n<tr>\n<td>reason_code</td>\n<td>STR0_255</td>\n<td>Reason for closing the channel</td>\n</tr>\n</tbody>\n</table>\n<p>If a proxy is operating in channel aggregating mode (translating downstream channels into aggregated extended upstream channels), it MUST send an <code>UpdateChannel</code> message when it receives <code>CloseChannel</code> or connection closure from a downstream connection.\nIn general, proxy servers MUST keep the upstream node notified about the real state of the downstream channels.</p>\n<h3>5.3.10 <code>SetExtranoncePrefix</code> (Server -&gt; Client)</h3>\n<p>Changes downstream node’s extranonce prefix.\nIt is applicable for all jobs sent after this message on a given channel (both jobs provided by the upstream or jobs introduced by <code>SetCustomMiningJob</code> message).\nThis message is applicable only for explicitly opened extended channels or standard channels (not group channels).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Extended or standard channel identifier</td>\n</tr>\n<tr>\n<td>extranonce_prefix</td>\n<td>B0_32</td>\n<td>Bytes used as implicit first part of extranonce</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.11 <code>SubmitSharesStandard</code> (Client -&gt; Server)</h3>\n<p>Client sends result of its hashing work to the server.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identification</td>\n</tr>\n<tr>\n<td>sequence_number</td>\n<td>U32</td>\n<td>Unique sequential identifier of the submit within the channel</td>\n</tr>\n<tr>\n<td>job_id</td>\n<td>U32</td>\n<td>Identifier of the job as provided by NewMiningJob or NewExtendedMiningJob message</td>\n</tr>\n<tr>\n<td>nonce</td>\n<td>U32</td>\n<td>Nonce leading to the hash being submitted</td>\n</tr>\n<tr>\n<td>ntime</td>\n<td>U32</td>\n<td>The nTime field in the block header. This MUST be greater than or equal to the header_timestamp field in the latest SetNewPrevHash message and lower than or equal to that value plus the number of seconds since the receipt of that message.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Full nVersion field</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.12 <code>SubmitSharesExtended</code> (Client -&gt; Server)</h3>\n<p>Only relevant for extended channels.\nThe message is the same as <code>SubmitShares</code>, with the following additional field:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;SubmitSharesStandard message fields&gt;</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>extranonce</td>\n<td>B0_32</td>\n<td>Extranonce bytes which need to be added to coinbase to form a fully valid submission (full coinbase = coinbase_tx_prefix + extranonce_prefix + extranonce + coinbase_tx_suffix). The size of the provided extranonce MUST be equal to the negotiated extranonce size from channel opening.</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.13 <code>SubmitShares.Success</code> (Server -&gt; Client)</h3>\n<p>Response to <code>SubmitShares</code> or <code>SubmitSharesExtended</code>, accepting results from the miner.\nBecause it is a common case that shares submission is successful, this response can be provided for multiple <code>SubmitShare</code> messages aggregated together.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identification</td>\n</tr>\n<tr>\n<td>last_sequence_number</td>\n<td>U32</td>\n<td>Most recent sequence number with a correct result</td>\n</tr>\n<tr>\n<td>new_submits_accepted_count</td>\n<td>U32</td>\n<td>Count of new submits acknowledged within this batch</td>\n</tr>\n<tr>\n<td>new_shares_sum</td>\n<td>U64</td>\n<td>Sum of shares acknowledged within this batch</td>\n</tr>\n</tbody>\n</table>\n<p>The server does not have to double check that the sequence numbers sent by a client are actually increasing.\nIt can simply use the last one received when sending a response.\nIt is the client’s responsibility to keep the sequence numbers correct/useful.</p>\n<h3>5.3.14 <code>SubmitShares.Error</code> (Server -&gt; Client)</h3>\n<p>An error is immediately submitted for every incorrect submit attempt.\nIn case the server is not able to immediately validate the submission, the error is sent as soon as the result is known.\nThis delayed validation can occur when a miner gets faster updates about a new prevhash than the server does (see <code>NewPrevHash</code> message for details).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identifier</td>\n</tr>\n<tr>\n<td>sequence_number</td>\n<td>U32</td>\n<td>Submission sequence number for which this error is returned</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Human-readable error code(s), see Error Codes section below</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>invalid-channel-id</code></li>\n<li><code>stale-share</code></li>\n<li><code>difficulty-too-low</code></li>\n<li><code>invalid-job-id</code></li>\n</ul>\n<h3>5.3.15 <code>NewMiningJob</code> (Server -&gt; Client)</h3>\n<p>The server provides an updated mining job to the client through a standard channel. This MUST be the first message after the channel has been successfully opened. This first message will have min_ntime unset (future job).</p>\n<p>If the <code>min_ntime</code> field is set, the client MUST start to mine on the new job immediately after receiving this message, and use the value for the initial nTime.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identifier, this must be a standard channel</td>\n</tr>\n<tr>\n<td>job_id</td>\n<td>U32</td>\n<td>Identifier of the job as provided by NewMiningJob or NewExtendedMiningJob message</td>\n</tr>\n<tr>\n<td>min_ntime</td>\n<td>OPTION[u32]</td>\n<td>Smallest nTime value available for hashing for the new mining job. An empty value indicates this is a future job to be activated once a SetNewPrevHash message is received with a matching job_id. This SetNewPrevHash message provides the new prev_hash and min_ntime. If the min_ntime value is set, this mining job is active and miner must start mining on it immediately. In this case, the new mining job uses the prev_hash from the last received SetNewPrevHash message.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Valid version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value.</td>\n</tr>\n<tr>\n<td>merkle_root</td>\n<td>U256</td>\n<td>Merkle root field as used in the bitcoin block header</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.16 <code>NewExtendedMiningJob</code> (Server -&gt; Client)</h3>\n<p>(Extended and group channels only)</p>\n<p>For an <strong>extended channel</strong>:\nThe whole search space of the job is owned by the specified channel.\nIf the <code>min_ntime</code> field is set to some nTime, the client MUST start to mine on the new job as soon as possible after receiving this message.</p>\n<p>For a <strong>group channel</strong>:\nThis is a broadcast variant of <code>NewMiningJob</code> message with the <code>merkle_root</code> field replaced by <code>merkle_path</code> and coinbase transaction prefix and suffix, for further traffic optimization.\nThe Merkle root is then defined deterministically for each channel by the common <code>merkle_path</code> and unique <code>extranonce_prefix</code> serialized into the coinbase.\nThe full coinbase is then constructed as follows: <code>coinbase_tx_prefix + extranonce_prefix + coinbase_tx_suffix</code>.</p>\n<p>The proxy MAY transform this multicast variant for downstream standard channels into <code>NewMiningJob</code> messages by computing the derived Merkle root for them.\nA proxy MUST translate the message for all downstream channels belonging to the group which don’t signal that they accept extended mining jobs in the <code>SetupConnection</code> message (intended and expected behavior for end mining devices).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>For a group channel, the message is broadcasted to all standard channels belonging to the group. Otherwise, it is addressed to the specified extended channel.</td>\n</tr>\n<tr>\n<td>job_id</td>\n<td>U32</td>\n<td>Server’s identification of the mining job</td>\n</tr>\n<tr>\n<td>min_ntime</td>\n<td>OPTION[u32]</td>\n<td>Smallest nTime value available for hashing for the new mining job. An empty value indicates this is a future job to be activated once a SetNewPrevHash message is received with a matching job_id. This SetNewPrevHash message provides the new prev_hash and min_ntime. If the min_ntime value is set, this mining job is active and miner must start mining on it immediately. In this case, the new mining job uses the prev_hash from the last received SetNewPrevHash message. immediately.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Valid version field that reflects the current network consensus</td>\n</tr>\n<tr>\n<td>version_rolling_allowed</td>\n<td>BOOL</td>\n<td>If set to True, the general purpose bits of version (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value. If set to False, the downstream node MUST use version as it is defined by this message.</td>\n</tr>\n<tr>\n<td>merkle_path</td>\n<td>SEQ0_255[U256]</td>\n<td>Merkle path hashes ordered from deepest</td>\n</tr>\n<tr>\n<td>coinbase_tx_prefix</td>\n<td>B0_64K</td>\n<td>Prefix part of the coinbase transaction*</td>\n</tr>\n<tr>\n<td>coinbase_tx_suffix</td>\n<td>B0_64K</td>\n<td>Suffix part of the coinbase transaction</td>\n</tr>\n</tbody>\n</table>\n<p>*The full coinbase is constructed by inserting one of the following:</p>\n<ul>\n<li>For a <strong>standard channel</strong>: <code>extranonce_prefix</code></li>\n<li>For an <strong>extended channel</strong>: <code>extranonce_prefix + extranonce (=N bytes)</code>, where <code>N</code> is the negotiated extranonce space for the channel (<code>OpenMiningChannel.Success.extranonce_size</code>)</li>\n</ul>\n<h3>5.3.17 <code>SetNewPrevHash</code> (Server -&gt; Client, broadcast)</h3>\n<p>Prevhash is distributed whenever a new block is detected in the network by an upstream node or when a new downstream opens a channel.</p>\n<p>This message MAY be shared by all downstream nodes (sent only once to each channel group).\nClients MUST immediately start to mine on the provided prevhash.\nWhen a client receives this message, only the job referenced by Job ID is valid.\nThe remaining jobs already queued by the client have to be made invalid.</p>\n<p>Note: There is no need for block height in this message.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Group channel or channel that this prevhash is valid for</td>\n</tr>\n<tr>\n<td>job_id</td>\n<td>U32</td>\n<td>ID of a job that is to be used for mining with this prevhash. A pool may have provided multiple jobs for the next block height (e.g. an empty block or a block with transactions that are complementary to the set of transactions present in the current block template).</td>\n</tr>\n<tr>\n<td>prev_hash</td>\n<td>U256</td>\n<td>Previous block’s hash, block header field</td>\n</tr>\n<tr>\n<td>min_ntime</td>\n<td>U32</td>\n<td>Smallest nTime value available for hashing</td>\n</tr>\n<tr>\n<td>nbits</td>\n<td>U32</td>\n<td>Block header field</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.18 <code>SetCustomMiningJob</code> (Client -&gt; Server)</h3>\n<p>Can be sent only on extended channel.\n<code>SetupConnection.flags</code> MUST contain <code>REQUIRES_WORK_SELECTION</code> flag (work selection feature successfully declared).</p>\n<p>The downstream node has a custom job declared by a trusted external Job Declarator.\nThe <code>mining_job_token</code> provides the information for the pool to authorize the custom job that has been or will be declared between the Job Declarator and Pool.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Extended channel identifier</td>\n</tr>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified identifier for pairing responses</td>\n</tr>\n<tr>\n<td>mining_job_token</td>\n<td>B0_255</td>\n<td>Token provided by JDS which uniquely identifies the Custom Job that JDC has declared. See the Job Declaration Protocol for more details.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Valid version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node.</td>\n</tr>\n<tr>\n<td>prev_hash</td>\n<td>U256</td>\n<td>Previous block’s hash, found in the block header field</td>\n</tr>\n<tr>\n<td>min_ntime</td>\n<td>U32</td>\n<td>Smallest nTime value available for hashing</td>\n</tr>\n<tr>\n<td>nbits</td>\n<td>U32</td>\n<td>Block header field</td>\n</tr>\n<tr>\n<td>coinbase_tx_version</td>\n<td>U32</td>\n<td>The coinbase transaction nVersion field</td>\n</tr>\n<tr>\n<td>coinbase_prefix</td>\n<td>B0_255</td>\n<td>Up to 8 bytes (not including the length byte) which are to be placed at the beginning of the coinbase field in the coinbase transaction.</td>\n</tr>\n<tr>\n<td>coinbase_tx_input_nSequence</td>\n<td>U32</td>\n<td>The coinbase transaction input’s nSequence field</td>\n</tr>\n<tr>\n<td>coinbase_tx_value_remaining</td>\n<td>U64</td>\n<td>The value, in satoshis, available for spending in coinbase outputs added by the client. Includes both transaction fees and block subsidy.</td>\n</tr>\n<tr>\n<td>coinbase_tx_outputs</td>\n<td>B0_64K</td>\n<td>Bitcoin transaction outputs to be included as the last outputs in the coinbase transaction</td>\n</tr>\n<tr>\n<td>coinbase_tx_locktime</td>\n<td>U32</td>\n<td>The locktime field in the coinbase transaction</td>\n</tr>\n<tr>\n<td>merkle_path</td>\n<td>SEQ0_255[U256]</td>\n<td>Merkle path hashes ordered from deepest</td>\n</tr>\n</tbody>\n</table>\n<h3>5.3.19 <code>SetCustomMiningJob.Success</code> (Server -&gt; Client)</h3>\n<p>Response from the Pool when it accepts the custom mining job.</p>\n<p>Up until receiving this message (and after having all the necessary information to start hashing), the miner SHOULD start hashing and buffer the work optimistically.</p>\n<p>This message acts as a commitment from the Pool to rewarding this job. In case the Pool does not commit (either by timeout, or responding with <code>SetCustomMiningJob.Error</code>), the miner SHOULD fall back to a different Pool (or solo).</p>\n<p>After receiving it, the miner can start submitting shares for this job immediately (by using the <code>job_id</code> provided within this response).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Extended channel identifier</td>\n</tr>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified identifier for pairing responses. Value from the request</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>MUST be provided by upstream in the response message.</td>\n</tr>\n<tr>\n<td>job_id</td>\n<td>U32</td>\n<td>Server’s identification of the mining job</td>\n</tr>\n</tbody>\n</table>\n<p>*The full coinbase is constructed by inserting one of the following:</p>\n<ul>\n<li>For a <strong>standard channel</strong>: <code>extranonce_prefix</code></li>\n<li>For an <strong>extended channel</strong>: <code>extranonce_prefix + extranonce (=N bytes)</code>, where <code>N</code> is the negotiated extranonce space for the channel (<code>OpenMiningChannel.Success.extranonce_size</code>)</li>\n</ul>\n<h3>5.3.20 <code>SetCustomMiningJob.Error</code> (Server -&gt; Client)</h3>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Extended channel identifier</td>\n</tr>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Client-specified identifier for pairing responses. Value from the request MUST be provided by upstream in the response message.</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Reason why the custom job has been rejected</td>\n</tr>\n</tbody>\n</table>\n<p>Possible errors:</p>\n<ul>\n<li><code>invalid-channel-id</code></li>\n<li><code>invalid-mining-job-token</code></li>\n<li><code>invalid-job-param-value-{}</code> - <code>{}</code> is replaced by a particular field name from <code>SetCustomMiningJob</code> message</li>\n</ul>\n<h3>5.3.21 <code>SetTarget</code> (Server -&gt; Client)</h3>\n<p>The server controls the submission rate by adjusting the difficulty target on a specified channel.\nAll submits leading to hashes higher than the specified target will be rejected by the server.</p>\n<p>Maximum target is valid until the next <code>SetTarget</code> message is sent and is applicable for all jobs received on the channel in the future or already received with an empty <code>min_ntime</code>.\nThe message is not applicable for already received jobs with <code>min_ntime=nTime</code>, as their maximum target remains stable.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>channel_id</td>\n<td>U32</td>\n<td>Channel identifier</td>\n</tr>\n<tr>\n<td>maximum_target</td>\n<td>U256</td>\n<td>Maximum value of produced hash that will be accepted by a server to accept shares</td>\n</tr>\n</tbody>\n</table>\n<p>When <code>SetTarget</code> is sent to a group channel, the maximum target is applicable to all channels in the group.</p>\n<h3>5.3.22 <code>SetGroupChannel</code> (Server -&gt; Client)</h3>\n<p>Every standard channel is a member of a group of standard channels, addressed by the upstream server’s provided identifier.\nThe group channel is used mainly for efficient job distribution to multiple standard channels at once.</p>\n<p>If we want to allow different jobs to be served to different standard channels (e.g. because of different <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki\">BIP 8</a> version bits) and still be able to distribute the work by sending <code>NewExtendendedMiningJob</code> instead of a repeated <code>NewMiningJob</code>, we need a more fine-grained grouping for standard channels.</p>\n<p>This message associates a set of standard channels with a group channel.\nA channel (identified by particular ID) becomes a group channel when it is used by this message as <code>group_channel_id</code>.\nThe server MUST ensure that a group channel has a unique channel ID within one connection. Channel reinterpretation is not allowed.</p>\n<p>This message can be sent only to connections that don’t have <code>REQUIRES_STANDARD_JOBS</code> flag in <code>SetupConnection</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>group_channel_id</td>\n<td>U32</td>\n<td>Identifier of the group where the standard channel belongs</td>\n</tr>\n<tr>\n<td>channel_ids</td>\n<td>SEQ0_64K[U32]</td>\n<td>A sequence of opened standard channel IDs, for which the group channel is being redefined</td>\n</tr>\n</tbody>\n</table>\n"
  },
  "06-Job-Declaration-Protocol": {
    "slug": "06-Job-Declaration-Protocol",
    "content": "# 6. Job Declaration Protocol\n\nThe Job Declaration Protocol is used to coordinate the creation of custom work, avoiding scenarios where Pools are unilaterally imposing work on miners.\n\nPools that opt into this protocol are only responsible for accounting shares and distributing rewards.\n\nThis is a key feature of Stratum V2 that improves Bitcoin decentralization.\n\n## 6.1 Job Declarator Server\n\nThe Job Declarator Server (JDS) is deployed on Pool side, although it could be theoretically outsourced to a third party that is trusted by the Pool.\n\nIn order to fully implement the Server side of the Job Declaration Protocol, the JDS also needs to exchange RPCs (or similar) with a Bitcoin Node. \n\nIt is responsible for:\n- Allocating tokens that JDC will use to declare Custom Jobs.\n- Acknowledging declaration of Custom Jobs associated with specific allocated tokens.\n- Maintaining an internal mempool (via RPCs (or similar) to a Bitcoin Node).\n- Requesting identification for transactions on some declared Custom Job.\n- Requesting missing transactions on some declared Custom Job.\n- Publishing valid block submissions received from JDC.\n\n## 6.2 Job Declarator Client\n\nThe Job Declarator Client (JDC) is deployed on the miner side.\n\nIn order to fully implement the Client side of the Job Declaration Protocol, the JDC also needs to operate under the Template Distribution and Mining Protocols.\n\nIt is responsible for:\n- Receiving Templates from the Template Provider (via Template Distribution Protocol).\n- Declaring Custom Jobs to JDS (via Job Declaration Protocol under Full-Template mode).\n- Notifying declared Custom Jobs to Pool (via Mining Protocol).\n- Receiving Shares from downstream Mining Devices working on Custom Jobs (via Mining Protocol).\n- Submitting Shares for Custom Jobs to Pool.\n- Publishing valid blocks found by downstream Mining Devices (both to Template Provider (TP) and JDS).\n\nAdditionally, if:\n- JDS fails to respond with an `AllocateMiningJobToken.Success` in a reasonable time.\n- JDS rejects some Custom Job declaration via `DeclareMiningJob.Error`.\n- Pool rejects valid shares under a Custom Job that was previously acknowledged via `SetCustomMiningJob.Success` and/or `DeclareMiningJob.Success`.\n\nJDC is also responsible for switching to a new Pool+JDS (or solo mining as a last resort).\n\nThis fallback strategy incentivizes honesty on Pool side, otherwise it will lose hashrate by rejecting Shares for a Custom Job that was already acknowledged to be valid.\n\n## 6.3 Job Declaration Modes\n\n### 6.3.1 Coinbase-only Mode\n\nUnder Coinbase-only mode:\n- JDS allocates `mining_job_token` to JDC (`AllocateMiningJobToken` / `AllocateMiningJobToken.Success`).\n- Pool evaluates fee revenue of some proposed work (uniquely identified by `mining_job_token`) by looking at the coinbase.\n- JDC never reveals the tx data contained in the template (in other words, the transaction set).\n- proposed work is acknowledged as valid by Pool via `SetCustomMiningJob.Success`.\n- the `DeclareMiningJob` message is never used.\n- if a valid block is found, JDC propagates it unilaterally.\n\nIn other words, Pool + JDS operating under Coinbase-only mode do not require to ever know which transactions are included in the miner template, preserving the privacy around the miner's mempool.\n\nThis leaves Pool arguably vulnerable to an attack where miner declares a coinbase with some fee revenue while one of the following situations is true:\n- the template actually has a different fee revenue.\n- the template has invalid transactions.\n\nThis potential attack vector is in many ways identical to block withholding and defenses against block withholding generally apply.\n\nSome pools may wish to utilize additional mitigations. For example, Zero-Knowledge-Proof based protocol extensions, where JDC proves that the fee revenue on the coinbase belongs to a valid template, without ever revealing the template itself.\n\n![](./img/jd_coinbase_mode.png)\n\nAs soon as JDC has:\n- a token (allocated by JDS), so it can use it to identify some unique work that it wants to advertise\n- a new template\n\nIt SHOULD start sending the jobs downstream for hashing right away. The proof-of-work (shares) SHOULD be cached until JDC receives an acknowledgement via `SetCustomMiningJob.Success`.\n\nWe call this **optimistic mining**.\n\n### 6.3.2 Full-Template Mode\n\nUnder Full-Template mode:\n- JDS allocates `mining_job_token` to JDC (`AllocateMiningJobToken` / `AllocateMiningJobToken.Success`).\n- JDC sends `DeclareMiningJob` to JDS (containing the `txid` of every transaction in the template).\n- JDS could potentially request for JDC to reveal `txdata` (via `ProvideMissingTransactions`).\n- JDS acknowledges proposed work via `DeclareMiningJob.Success`.\n- JDC notifies work to Pool via `SetCustomMiningJob`, acknowledged via `SetCustomMiningJob.Success`.\n- if a valid block is found, both JDC and JDS propagate it.\n\n![](./img/jd_template_mode.png)\n\nSimilarly to Coinbase-only, as soon as JDC has:\n- a token (allocated by JDS), so it can use it to identify some unique work that it wants to advertise\n- a new template\n\nIt SHOULD do optimistic mining by sending the jobs downstream for hashing right away. The proof-of-work (shares) SHOULD be cached until JDC receives an acknowledgement via `SetCustomMiningJob.Success`.\n\n### 6.3.3 Coinbase-only vs Full-Template\n\nThe table below shows a comparison between the two Sv2 Job Declation Modes:\n\n|                                     | Coinbase-only | Full-Template |\n|-------------------------------------|-|-|\n| knowledge of fee revenue            | • JDC <br> • Pool (while blind against tx data) | • JDC <br> • Pool (while blind against tx data) <br> • JDS (verifying against revealed tx data on behalf of Pool) |\n| knowledge of txdata on the template | • JDC | • JDC <br> • JDS (on behalf of Pool) |\n| ability to broadcast mined block    | • JDC | • JDC <br> • JDS (on behalf of Pool) |\n\n## 6.4 Job Declaration Protocol Messages\n\n### 6.4.1 `SetupConnection` Flags for Job Declaration Protocol\n\nFlags usable in `SetupConnection.flags` and `SetupConnection.Error::flags`:\n\n| Field Name                | Bit | Description                                                                                                                                                                                                                                                                                                                                                          |\n| ------------------------- | --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| DECLARE_TX_DATA | 0   | JDC agrees to reveal the template's txdata via `DeclareMiningJob` and `ProvideMissingTransactions`. |\n\nNo flags are yet defined for use in `SetupConnection.Success`.\n\n### 6.4.2 `AllocateMiningJobToken` (JDC -> JDS)\n\nA request to get an identifier for a future-submitted mining job.\nRate limited to a rather slow rate and only available on connections where this has been negotiated. Otherwise, only `mining_job_token(s)` from `AllocateMiningJobToken.Success` are valid.\n\n| Field Name      | Data Type | Description                                                                                                                                                                                                                        |\n| --------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| user_identifier | STR0_255  | Unconstrained sequence of bytes. Whatever is needed by the pool to identify/authenticate the client, e.g. \"braiinstest\". Additional restrictions can be imposed by the pool. It is highly recommended that UTF-8 encoding is used. |\n| request_id      | U32       | Unique identifier for pairing the response                                                                                                                                                                                         |\n\n### 6.4.3 `AllocateMiningJobToken.Success` (Server -> Client)\n\nThe Server MUST NOT change the value of `coinbase_output_max_additional_size` in `AllocateMiningJobToken.Success` messages unless required for changes to the pool’s configuration.\nNotably, if the pool intends to change the space it requires for coinbase transaction outputs regularly, it should simply prefer to use the maximum of all such output sizes as the `coinbase_output_max_additional_size` value.\n\n| Field Name                          | Data Type | Description                                                                                                                                                                                                                                                                                                                                                              |\n| ----------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| request_id                          | U32       | Unique identifier for pairing the response                                                                                                                                                                                                                                                                                                                               |\n| mining_job_token                    | B0_255    | Token that makes the client eligible for committing a mining job for approval/transaction declaration or for identifying custom mining job on mining connection.                                                                                                                                                                                                         |\n| coinbase_output_max_additional_size | U32       | The maximum additional serialized bytes which the pool will add in coinbase transaction outputs. See discussion in the Template Distribution Protocol's CoinbaseOutputConstraints message for more details.                                                                                                                                                                 |\n| coinbase_output_max_additional_sigops | U16 | The maximum additional sigops which the pool will add in coinbase transaction outputs. See discussion in the Template Distribution Protocol's CoinbaseOutputConstraints message for more details. |\n| coinbase_tx_outputs         | B0_64K         | Bitcoin transaction outputs added by the pool                                                                            |\n\n### 6.4.4 `DeclareMiningJob` (Client -> Server)\n\nOnly used in Full-Template mode.\n\nA request sent by JDC that proposes a selected set of transactions to JDS.\n\n| Field Name                  | Data Type             | Description                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| --------------------------- | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| request_id                  | U32                   | Unique identifier for pairing the response                                                                                                                                                                                                                                                                                                                                                                                   |\n| mining_job_token            | B0_255                | Previously reserved mining job token received by AllocateMiningJobToken.Success                                                                                                                                                                                                                                                                                                                                              |\n| version                     | U32                   | Version header field. To be later modified by BIP320-consistent changes.                                                                                                                                                                                                                                                                                                                                                     |\n| prev_hash                   | U256                  | Optional. Contains the chain tip that the template is based on. JDS SHOULD accept templates based on different tips, as long as they are on the best block height and don't contain double spends.                                                                                                                                                                                                                           |\n| coinbase_tx_prefix         | B0_64K                 | Serialized bytes representing the initial part of the coinbase transaction (not including extranonce)                                                                                                                                                                                                                                                                                                                                                                                      |\n| coinbase_tx_suffix         | B0_64K                 | Serialized bytes representing the final part of the coinbase transaction (after extranonce)                                                                                                                                                                                                                                                                                     |\n| tx_ids_list               | SEQ0_64K[U256] | List of hashes of the transaction set contained in the template. JDS checks the list against its mempool and requests missing txs via `ProvideMissingTransactions`. Does not include the coinbase transaction (as there is no corresponding full data for it yet).                                                                                                                                                          |\n| excess_data                 | B0_64K                | Extra data which the Pool may require to validate the work (as defined in the Template Distribution Protocol)                                                                                                                                                                                                                                                                                                                |\n\n### 6.4.5 `DeclareMiningJob.Success` (Server -> Client)\n\nA response sent by JDS acknowledging some Custom Job declaration.\n\nJDS MAY request txdata via `ProvideMissingTransactions` before making this commitment.\n\nSince JDS could be third party (not necessarily integrated to Pool), `DeclareMiningJob.Success.new_mining_job_token` MAY carry a cryptographic commitment from JDS where:\n- JDS acknowledges that the template declared under `DeclareMiningJob.mining_job_token` is valid\n- it signals to JDC that it should use `SetCustomMininingJob.mining_job_token = DeclareMiningJob.Success.new_mining_job_token` when declaring Custom Jobs to Pool as a way to prove it went through the Full-Template declaration process\n\n| Field Name           | Data Type | Description                         |\n| -------------------- | --------- |-------------------------------------|\n| request_id           | U32       | Identifier of the original request. |\n| new_mining_job_token | B0_255    | Unique custom work identifier.      |\n\n### 6.4.6 `DeclareMiningJob.Error` (Server->Client)\n\nA response sent by JDS rejecting some Custom Job declaration.\n\nThis should be a trigger for fallback into some other Pool+JDS or solo mining.\n\n| Field Name    | Data Type | Description                                            |\n| ------------- | --------- | ------------------------------------------------------ |\n| request_id    | U32       | Identifier of the original request                     |\n| error_code    | STR0_255  |                                                        |\n| error_details | B0_64K    | Optional data providing further details to given error |\n\nPossible error codes:\n\n- `invalid-mining-job-token`\n- `invalid-job-param-value-{}` - `{}` is replaced by a particular field name from `DeclareMiningJob` message\n\n### 6.4.7 `ProvideMissingTransactions` (Server->Client)\n\nOnly used in Full-Template mode.\n\nIf `DeclareMiningJob` includes some transactions that JDS's mempool has not yet seen, then JDS needs to request that JDC provides those missing ones.\n\n| Field Name               | Data Type     | Description                                                                                                                                                                                                                              |\n| ------------------------ | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| request_id               | U32           | Identifier of the original AllocateMiningJobToken request                                                                                                                                                                                |\n| unknown_tx_position_list | SEQ0_64K[U16] | A list of unrecognized transactions that need to be supplied by the Job Declarator in full. They are specified by their position in the original DeclareMiningJob message, 0-indexed not including the coinbase transaction transaction. |\n\n### 6.4.8 `ProvideMissingTransactions.Success` (Client->Server)\nThis is a message to push transactions that the server did not recognize and requested them to be supplied in `ProvideMissingTransactions`.\n\n| Field Name       | Data Type        | Description                                                                                                                          |\n| ---------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| request_id       | U32              | Identifier of the original  AllocateMiningJobToken request                                                                           \"\"|\n| transaction_list | SEQ0_64K[B0_16M] | List of full transactions as requested by ProvideMissingTransactions, in the order they were requested in ProvideMissingTransactions |\n\n### 6.4.9 `PushSolution` (Client -> Server)\n\nOnly used in Full-Template mode.\n\nSent by JDC as soon as a valid block is found, so that it can be propagated also by JDS.\n\nIn the meantime, the block is also transmitted to the network by JDC through the `SubmitSolution` message under in Template Distribution Protocol.\n\nIn this way, a valid solution is immediately propagated on both client and server sides, decreasing the chance of the block being orphaned by the network.\n\n| Field Name                              | Data Type | Description                                                                                                                                                                                                                                                                                |\n| --------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| extranonce                              | B0_32     | Extranonce bytes which need to be added to coinbase to form a fully valid submission.  (This is the full extranonce)                 |\n| prev hash                               | U256      | Hash of the last block                                                                                  |\n| nonce                                   | U32       | Nonce leading to the hash being submitted                                                               |\n| ntime                                   | U32       | The nTime field in the block header.                                                                    |\n| nbits                                   | U32       | The nBits field in the block header.                                                                    |\n| version                                 | U32       | Version header field.                                                                                   |\n",
    "html": "<h1>6. Job Declaration Protocol</h1>\n<p>The Job Declaration Protocol is used to coordinate the creation of custom work, avoiding scenarios where Pools are unilaterally imposing work on miners.</p>\n<p>Pools that opt into this protocol are only responsible for accounting shares and distributing rewards.</p>\n<p>This is a key feature of Stratum V2 that improves Bitcoin decentralization.</p>\n<h2>6.1 Job Declarator Server</h2>\n<p>The Job Declarator Server (JDS) is deployed on Pool side, although it could be theoretically outsourced to a third party that is trusted by the Pool.</p>\n<p>In order to fully implement the Server side of the Job Declaration Protocol, the JDS also needs to exchange RPCs (or similar) with a Bitcoin Node.</p>\n<p>It is responsible for:</p>\n<ul>\n<li>Allocating tokens that JDC will use to declare Custom Jobs.</li>\n<li>Acknowledging declaration of Custom Jobs associated with specific allocated tokens.</li>\n<li>Maintaining an internal mempool (via RPCs (or similar) to a Bitcoin Node).</li>\n<li>Requesting identification for transactions on some declared Custom Job.</li>\n<li>Requesting missing transactions on some declared Custom Job.</li>\n<li>Publishing valid block submissions received from JDC.</li>\n</ul>\n<h2>6.2 Job Declarator Client</h2>\n<p>The Job Declarator Client (JDC) is deployed on the miner side.</p>\n<p>In order to fully implement the Client side of the Job Declaration Protocol, the JDC also needs to operate under the Template Distribution and Mining Protocols.</p>\n<p>It is responsible for:</p>\n<ul>\n<li>Receiving Templates from the Template Provider (via Template Distribution Protocol).</li>\n<li>Declaring Custom Jobs to JDS (via Job Declaration Protocol under Full-Template mode).</li>\n<li>Notifying declared Custom Jobs to Pool (via Mining Protocol).</li>\n<li>Receiving Shares from downstream Mining Devices working on Custom Jobs (via Mining Protocol).</li>\n<li>Submitting Shares for Custom Jobs to Pool.</li>\n<li>Publishing valid blocks found by downstream Mining Devices (both to Template Provider (TP) and JDS).</li>\n</ul>\n<p>Additionally, if:</p>\n<ul>\n<li>JDS fails to respond with an <code>AllocateMiningJobToken.Success</code> in a reasonable time.</li>\n<li>JDS rejects some Custom Job declaration via <code>DeclareMiningJob.Error</code>.</li>\n<li>Pool rejects valid shares under a Custom Job that was previously acknowledged via <code>SetCustomMiningJob.Success</code> and/or <code>DeclareMiningJob.Success</code>.</li>\n</ul>\n<p>JDC is also responsible for switching to a new Pool+JDS (or solo mining as a last resort).</p>\n<p>This fallback strategy incentivizes honesty on Pool side, otherwise it will lose hashrate by rejecting Shares for a Custom Job that was already acknowledged to be valid.</p>\n<h2>6.3 Job Declaration Modes</h2>\n<h3>6.3.1 Coinbase-only Mode</h3>\n<p>Under Coinbase-only mode:</p>\n<ul>\n<li>JDS allocates <code>mining_job_token</code> to JDC (<code>AllocateMiningJobToken</code> / <code>AllocateMiningJobToken.Success</code>).</li>\n<li>Pool evaluates fee revenue of some proposed work (uniquely identified by <code>mining_job_token</code>) by looking at the coinbase.</li>\n<li>JDC never reveals the tx data contained in the template (in other words, the transaction set).</li>\n<li>proposed work is acknowledged as valid by Pool via <code>SetCustomMiningJob.Success</code>.</li>\n<li>the <code>DeclareMiningJob</code> message is never used.</li>\n<li>if a valid block is found, JDC propagates it unilaterally.</li>\n</ul>\n<p>In other words, Pool + JDS operating under Coinbase-only mode do not require to ever know which transactions are included in the miner template, preserving the privacy around the miner’s mempool.</p>\n<p>This leaves Pool arguably vulnerable to an attack where miner declares a coinbase with some fee revenue while one of the following situations is true:</p>\n<ul>\n<li>the template actually has a different fee revenue.</li>\n<li>the template has invalid transactions.</li>\n</ul>\n<p>This potential attack vector is in many ways identical to block withholding and defenses against block withholding generally apply.</p>\n<p>Some pools may wish to utilize additional mitigations. For example, Zero-Knowledge-Proof based protocol extensions, where JDC proves that the fee revenue on the coinbase belongs to a valid template, without ever revealing the template itself.</p>\n<p><img src=\"./img/jd_coinbase_mode.png\" alt=\"\"></p>\n<p>As soon as JDC has:</p>\n<ul>\n<li>a token (allocated by JDS), so it can use it to identify some unique work that it wants to advertise</li>\n<li>a new template</li>\n</ul>\n<p>It SHOULD start sending the jobs downstream for hashing right away. The proof-of-work (shares) SHOULD be cached until JDC receives an acknowledgement via <code>SetCustomMiningJob.Success</code>.</p>\n<p>We call this <strong>optimistic mining</strong>.</p>\n<h3>6.3.2 Full-Template Mode</h3>\n<p>Under Full-Template mode:</p>\n<ul>\n<li>JDS allocates <code>mining_job_token</code> to JDC (<code>AllocateMiningJobToken</code> / <code>AllocateMiningJobToken.Success</code>).</li>\n<li>JDC sends <code>DeclareMiningJob</code> to JDS (containing the <code>txid</code> of every transaction in the template).</li>\n<li>JDS could potentially request for JDC to reveal <code>txdata</code> (via <code>ProvideMissingTransactions</code>).</li>\n<li>JDS acknowledges proposed work via <code>DeclareMiningJob.Success</code>.</li>\n<li>JDC notifies work to Pool via <code>SetCustomMiningJob</code>, acknowledged via <code>SetCustomMiningJob.Success</code>.</li>\n<li>if a valid block is found, both JDC and JDS propagate it.</li>\n</ul>\n<p><img src=\"./img/jd_template_mode.png\" alt=\"\"></p>\n<p>Similarly to Coinbase-only, as soon as JDC has:</p>\n<ul>\n<li>a token (allocated by JDS), so it can use it to identify some unique work that it wants to advertise</li>\n<li>a new template</li>\n</ul>\n<p>It SHOULD do optimistic mining by sending the jobs downstream for hashing right away. The proof-of-work (shares) SHOULD be cached until JDC receives an acknowledgement via <code>SetCustomMiningJob.Success</code>.</p>\n<h3>6.3.3 Coinbase-only vs Full-Template</h3>\n<p>The table below shows a comparison between the two Sv2 Job Declation Modes:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Coinbase-only</th>\n<th>Full-Template</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>knowledge of fee revenue</td>\n<td>• JDC <br> • Pool (while blind against tx data)</td>\n<td>• JDC <br> • Pool (while blind against tx data) <br> • JDS (verifying against revealed tx data on behalf of Pool)</td>\n</tr>\n<tr>\n<td>knowledge of txdata on the template</td>\n<td>• JDC</td>\n<td>• JDC <br> • JDS (on behalf of Pool)</td>\n</tr>\n<tr>\n<td>ability to broadcast mined block</td>\n<td>• JDC</td>\n<td>• JDC <br> • JDS (on behalf of Pool)</td>\n</tr>\n</tbody>\n</table>\n<h2>6.4 Job Declaration Protocol Messages</h2>\n<h3>6.4.1 <code>SetupConnection</code> Flags for Job Declaration Protocol</h3>\n<p>Flags usable in <code>SetupConnection.flags</code> and <code>SetupConnection.Error::flags</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Bit</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DECLARE_TX_DATA</td>\n<td>0</td>\n<td>JDC agrees to reveal the template’s txdata via <code>DeclareMiningJob</code> and <code>ProvideMissingTransactions</code>.</td>\n</tr>\n</tbody>\n</table>\n<p>No flags are yet defined for use in <code>SetupConnection.Success</code>.</p>\n<h3>6.4.2 <code>AllocateMiningJobToken</code> (JDC -&gt; JDS)</h3>\n<p>A request to get an identifier for a future-submitted mining job.\nRate limited to a rather slow rate and only available on connections where this has been negotiated. Otherwise, only <code>mining_job_token(s)</code> from <code>AllocateMiningJobToken.Success</code> are valid.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user_identifier</td>\n<td>STR0_255</td>\n<td>Unconstrained sequence of bytes. Whatever is needed by the pool to identify/authenticate the client, e.g. “braiinstest”. Additional restrictions can be imposed by the pool. It is highly recommended that UTF-8 encoding is used.</td>\n</tr>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Unique identifier for pairing the response</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.3 <code>AllocateMiningJobToken.Success</code> (Server -&gt; Client)</h3>\n<p>The Server MUST NOT change the value of <code>coinbase_output_max_additional_size</code> in <code>AllocateMiningJobToken.Success</code> messages unless required for changes to the pool’s configuration.\nNotably, if the pool intends to change the space it requires for coinbase transaction outputs regularly, it should simply prefer to use the maximum of all such output sizes as the <code>coinbase_output_max_additional_size</code> value.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Unique identifier for pairing the response</td>\n</tr>\n<tr>\n<td>mining_job_token</td>\n<td>B0_255</td>\n<td>Token that makes the client eligible for committing a mining job for approval/transaction declaration or for identifying custom mining job on mining connection.</td>\n</tr>\n<tr>\n<td>coinbase_output_max_additional_size</td>\n<td>U32</td>\n<td>The maximum additional serialized bytes which the pool will add in coinbase transaction outputs. See discussion in the Template Distribution Protocol’s CoinbaseOutputConstraints message for more details.</td>\n</tr>\n<tr>\n<td>coinbase_output_max_additional_sigops</td>\n<td>U16</td>\n<td>The maximum additional sigops which the pool will add in coinbase transaction outputs. See discussion in the Template Distribution Protocol’s CoinbaseOutputConstraints message for more details.</td>\n</tr>\n<tr>\n<td>coinbase_tx_outputs</td>\n<td>B0_64K</td>\n<td>Bitcoin transaction outputs added by the pool</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.4 <code>DeclareMiningJob</code> (Client -&gt; Server)</h3>\n<p>Only used in Full-Template mode.</p>\n<p>A request sent by JDC that proposes a selected set of transactions to JDS.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Unique identifier for pairing the response</td>\n</tr>\n<tr>\n<td>mining_job_token</td>\n<td>B0_255</td>\n<td>Previously reserved mining job token received by AllocateMiningJobToken.Success</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Version header field. To be later modified by BIP320-consistent changes.</td>\n</tr>\n<tr>\n<td>prev_hash</td>\n<td>U256</td>\n<td>Optional. Contains the chain tip that the template is based on. JDS SHOULD accept templates based on different tips, as long as they are on the best block height and don’t contain double spends.</td>\n</tr>\n<tr>\n<td>coinbase_tx_prefix</td>\n<td>B0_64K</td>\n<td>Serialized bytes representing the initial part of the coinbase transaction (not including extranonce)</td>\n</tr>\n<tr>\n<td>coinbase_tx_suffix</td>\n<td>B0_64K</td>\n<td>Serialized bytes representing the final part of the coinbase transaction (after extranonce)</td>\n</tr>\n<tr>\n<td>tx_ids_list</td>\n<td>SEQ0_64K[U256]</td>\n<td>List of hashes of the transaction set contained in the template. JDS checks the list against its mempool and requests missing txs via <code>ProvideMissingTransactions</code>. Does not include the coinbase transaction (as there is no corresponding full data for it yet).</td>\n</tr>\n<tr>\n<td>excess_data</td>\n<td>B0_64K</td>\n<td>Extra data which the Pool may require to validate the work (as defined in the Template Distribution Protocol)</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.5 <code>DeclareMiningJob.Success</code> (Server -&gt; Client)</h3>\n<p>A response sent by JDS acknowledging some Custom Job declaration.</p>\n<p>JDS MAY request txdata via <code>ProvideMissingTransactions</code> before making this commitment.</p>\n<p>Since JDS could be third party (not necessarily integrated to Pool), <code>DeclareMiningJob.Success.new_mining_job_token</code> MAY carry a cryptographic commitment from JDS where:</p>\n<ul>\n<li>JDS acknowledges that the template declared under <code>DeclareMiningJob.mining_job_token</code> is valid</li>\n<li>it signals to JDC that it should use <code>SetCustomMininingJob.mining_job_token = DeclareMiningJob.Success.new_mining_job_token</code> when declaring Custom Jobs to Pool as a way to prove it went through the Full-Template declaration process</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Identifier of the original request.</td>\n</tr>\n<tr>\n<td>new_mining_job_token</td>\n<td>B0_255</td>\n<td>Unique custom work identifier.</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.6 <code>DeclareMiningJob.Error</code> (Server-&gt;Client)</h3>\n<p>A response sent by JDS rejecting some Custom Job declaration.</p>\n<p>This should be a trigger for fallback into some other Pool+JDS or solo mining.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Identifier of the original request</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td></td>\n</tr>\n<tr>\n<td>error_details</td>\n<td>B0_64K</td>\n<td>Optional data providing further details to given error</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>invalid-mining-job-token</code></li>\n<li><code>invalid-job-param-value-{}</code> - <code>{}</code> is replaced by a particular field name from <code>DeclareMiningJob</code> message</li>\n</ul>\n<h3>6.4.7 <code>ProvideMissingTransactions</code> (Server-&gt;Client)</h3>\n<p>Only used in Full-Template mode.</p>\n<p>If <code>DeclareMiningJob</code> includes some transactions that JDS’s mempool has not yet seen, then JDS needs to request that JDC provides those missing ones.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Identifier of the original AllocateMiningJobToken request</td>\n</tr>\n<tr>\n<td>unknown_tx_position_list</td>\n<td>SEQ0_64K[U16]</td>\n<td>A list of unrecognized transactions that need to be supplied by the Job Declarator in full. They are specified by their position in the original DeclareMiningJob message, 0-indexed not including the coinbase transaction transaction.</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.8 <code>ProvideMissingTransactions.Success</code> (Client-&gt;Server)</h3>\n<p>This is a message to push transactions that the server did not recognize and requested them to be supplied in <code>ProvideMissingTransactions</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request_id</td>\n<td>U32</td>\n<td>Identifier of the original  AllocateMiningJobToken request                                                                           “”</td>\n</tr>\n<tr>\n<td>transaction_list</td>\n<td>SEQ0_64K[B0_16M]</td>\n<td>List of full transactions as requested by ProvideMissingTransactions, in the order they were requested in ProvideMissingTransactions</td>\n</tr>\n</tbody>\n</table>\n<h3>6.4.9 <code>PushSolution</code> (Client -&gt; Server)</h3>\n<p>Only used in Full-Template mode.</p>\n<p>Sent by JDC as soon as a valid block is found, so that it can be propagated also by JDS.</p>\n<p>In the meantime, the block is also transmitted to the network by JDC through the <code>SubmitSolution</code> message under in Template Distribution Protocol.</p>\n<p>In this way, a valid solution is immediately propagated on both client and server sides, decreasing the chance of the block being orphaned by the network.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>extranonce</td>\n<td>B0_32</td>\n<td>Extranonce bytes which need to be added to coinbase to form a fully valid submission.  (This is the full extranonce)</td>\n</tr>\n<tr>\n<td>prev hash</td>\n<td>U256</td>\n<td>Hash of the last block</td>\n</tr>\n<tr>\n<td>nonce</td>\n<td>U32</td>\n<td>Nonce leading to the hash being submitted</td>\n</tr>\n<tr>\n<td>ntime</td>\n<td>U32</td>\n<td>The nTime field in the block header.</td>\n</tr>\n<tr>\n<td>nbits</td>\n<td>U32</td>\n<td>The nBits field in the block header.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Version header field.</td>\n</tr>\n</tbody>\n</table>\n"
  },
  "07-Template-Distribution-Protocol": {
    "slug": "07-Template-Distribution-Protocol",
    "content": "# 7. Template Distribution Protocol\n\nThe Template Distribution protocol is used to receive updates of the block template to use in mining the next block.\nIt effectively replaces [BIP 22](https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki) and [BIP 23](https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki) (`getblocktemplate`) and provides a much more efficient API which allows Bitcoin Core (or some other full node software) to push template updates at more appropriate times as well as provide a template which may be mined on quickly for the block-after-next.\nWhile not recommended, the template update protocol can be a remote server, and is thus authenticated and signed in the same way as all other protocols (using the same SetupConnection handshake).\n\nLike the Job Declaration and Job Distribution protocols, all Template Distribution messages have the `channel_msg` bit unset, and there is no concept of channels.\nAfter the initial common handshake, the client MUST immediately send a `CoinbaseOutputConstraints` message to indicate the space it requires for coinbase output addition, to which the server MUST immediately reply with the current best block template it has available to the client.\nThereafter, the server SHOULD push new block templates to the client whenever the total fee in the current block template increases materially, and MUST send updated block templates whenever it learns of a new block.\n\nTemplate Providers MUST attempt to broadcast blocks which are mined using work they provided, and thus MUST track the work which they provided to clients.\n\n## 7.1 `CoinbaseOutputConstraints` (Client -> Server)\n\nUltimately, the pool is responsible for adding coinbase transaction outputs for payouts and other uses, and thus the Template Provider will need to consider this additional block size, and sigops when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\nThus, this message is used to indicate that some additional space and sigops in the block/coinbase transaction be reserved for the pool’s use (while always assuming the pool will use the entirety of available coinbase space and sigops).\n\nThe Job Declarator MUST discover the maximum serialized size of the additional outputs and sigops which will be added by the pool(s) it intends to use this work.\nIt then MUST communicate it to the Template Provider via this message.\nThe Template Provider MUST NOT provide `NewMiningJob` messages which would represent consensus-invalid blocks once this additional size and sigops — along with a maximally-sized (100 byte) coinbase script field — is added.\nFurther, the Template Provider MUST consider the maximum additional bytes required in the output count variable-length integer in the coinbase transaction when complying with the size limits.\nCurrent sigops limit per block in bitcoin is 80_000. We are not aware of any use cases where\ncoinbase have more the 65_535 so coinbase_output_max_sigops is an U16. Note that taproot outputs consume 0 sigops.\n\n| Field Name                          | Data Type | Description                                                                                     |\n| ----------------------------------- | --------- | ----------------------------------------------------------------------------------------------- |\n| coinbase_output_max_additional_size | U32       | The maximum additional serialized bytes which the pool will add in coinbase transaction outputs |\n| coinbase_output_max_additional_sigops          | U16       | The maximum additional sigops which the pool will add in coinbase transaction outputs           |\n\n## 7.2 `NewTemplate` (Server -> Client)\n\nThe primary template-providing function. Note that the `coinbase_tx_outputs` bytes will appear as is at the end of the coinbase transaction.\n\n| Field Name                  | Data Type      | Description                                                                                                                                                                                                                                                                        |\n| --------------------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| template_id                 | U64            | Server’s identification of the template. Strictly increasing, the current UNIX time may be used in place of an ID                                                                                                                                                                  |\n| future_template             | BOOL           | True if the template is intended for future SetNewPrevHash message sent on the channel. If False, the job relates to the last sent SetNewPrevHash message on the channel and the miner should start to work on the job immediately.                                                |\n| version                     | U32            | Valid header version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value. |\n| coinbase_tx_version         | U32            | The coinbase transaction nVersion field                                                                                                                                                                                                                                            |\n| coinbase_prefix             | B0_255         | Up to 8 bytes (not including the length byte) which are to be placed at the beginning of the coinbase field in the coinbase transaction                                                                                                                                            |\n| coinbase_tx_input_sequence  | U32            | The coinbase transaction input's nSequence field                                                                                                                                                                                                                                   |\n| coinbase_tx_value_remaining | U64            | The value, in satoshis, available for spending in coinbase outputs added by the client. Includes both transaction fees and block subsidy.                                                                                                                                          |\n| coinbase_tx_outputs_count   | U32            | The number of transaction outputs included in coinbase_tx_outputs                                                                                                                                                                                                                  |\n| coinbase_tx_outputs         | B0_64K         | Bitcoin transaction outputs to be included as the last outputs in the coinbase transaction                                                                                                                                                                                         |\n| coinbase_tx_locktime        | U32            | The locktime field in the coinbase transaction                                                                                                                                                                                                                                     |\n| merkle_path                 | SEQ0_255[U256] | Merkle path hashes ordered from deepest                                                                                                                                                                                                                                            |\n\n## 7.3 `SetNewPrevHash` (Server -> Client)\n\nUpon successful validation of a new best block, the server MUST immediately provide a `SetNewPrevHash` message.\nIf a `NewMiningJob` message has previously been sent with an empty `min_ntime`, which is valid work based on the `prev_hash` contained in this message, the `template_id` field SHOULD be set to the `job_id` present in that `NewTemplate` message indicating the client MUST begin mining on that template as soon as possible.\n\nTODO: Define how many previous works the client has to track (2? 3?), and require that the server reference one of those in `SetNewPrevHash`.\n\n| Field Name       | Data Type | Description                                                                                                                                                                                            |\n| ---------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| template_id      | U64       | template_id referenced in a previous NewTemplate message                                                                                                                                               |\n| prev_hash        | U256      | Previous block’s hash, as it must appear in the next block's header                                                                                                                                    |\n| header_timestamp | U32       | The nTime field in the block header at which the client should start (usually current time). This is NOT the minimum valid nTime value.                                                                |\n| nBits            | U32       | Block header field                                                                                                                                                                                     |\n| target           | U256      | The maximum double-SHA256 hash value which would represent a valid block. Note that this may be lower than the target implied by nBits in several cases, including weak-block based block propagation. |\n\n## 7.4 `RequestTransactionData` (Client -> Server)\n\nA request sent by the Job Declarator to the Template Provider which requests the set of transaction data for all transactions (excluding the coinbase transaction) included in a block, as well as any additional data which may be required by the Pool to validate the work.\n\n| Field Name  | Data Type | Description                                            |\n| ----------- | --------- | ------------------------------------------------------ |\n| template_id | U64       | The template_id corresponding to a NewTemplate message |\n\n## 7.5 `RequestTransactionData.Success` (Server->Client)\n\nA response to `RequestTransactionData` which contains the set of full transaction data and excess data required for validation.\nFor practical purposes, the excess data is usually the SegWit commitment, however the Job Declarator MUST NOT parse or interpret the excess data in any way.\nNote that the transaction data MUST be treated as opaque blobs and MUST include any SegWit or other data which the Pool may require to verify the transaction.\nFor practical purposes, the transaction data is likely the witness-encoded transaction today.\nHowever, to ensure backward compatibility, the transaction data MAY be encoded in a way that is different from the consensus serialization of Bitcoin transactions.\n\nUltimately, having some method of negotiating the specific format of transactions between the Template Provider and the Pool’s Template verification node would be overly burdensome, thus the following requirements are made explicit.\nThe `RequestTransactionData.Success` sender MUST ensure that the data is provided in a forwards- and backwards-compatible way to ensure the end receiver of the data can interpret it, even in the face of new, consensus-optional data.\nThis allows significantly more flexibility on both the `RequestTransactionData.Success`-generating and -interpreting sides during upgrades, at the cost of breaking some potential optimizations which would require version negotiation to provide support for previous versions.\nFor practical purposes, and as a non-normative suggested implementation for Bitcoin Core, this implies that additional consensus-optional data be appended at the end of transaction data.\nIt will simply be ignored by versions which do not understand it.\n\nTo work around the limitation of not being able to negotiate e.g. a transaction compression scheme, the format of the opaque data in `RequestTransactionData.Success` messages MAY be changed in non-compatible ways at the time a fork activates, given sufficient time from code-release to activation (as any sane fork would have to have) and there being some in-Template Negotiation Protocol signaling of support for the new fork (e.g. for soft-forks activated using [BIP 9](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki)).\n\n| Field Name       | Data Type        | Description                                                                                                                          |\n| ---------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| template_id      | U64              | The template_id corresponding to a NewTemplate/RequestTransactionData message                                                        |\n| excess_data      | B0_64K           | Extra data which the Pool may require to validate the work                                                                           |\n| transaction_list | SEQ0_64K[B0_16M] | List of full transactions as requested by ProvideMissingTransactions, in the order they were requested in ProvideMissingTransactions |\n\n## 7.6 `RequestTransactionData.Error` (Server->Client)\n\n| Field Name  | Data Type | Description                                                                   |\n| ----------- | --------- | ----------------------------------------------------------------------------- |\n| template_id | U64       | The template_id corresponding to a NewTemplate/RequestTransactionData message |\n| error_code  | STR0_255  | Reason why no transaction data has been provided                              |\n\nPossible error codes:\n\n- `template-id-not-found` - used when the template being referenced is too old and no longer stored in the memory of the Template Provider\n- `stale-template-id` - used when the prev_hash of the corresponding template is still in the Template Provider's memory, but it no longer points to the latest tip \n\n## 7.7 `SubmitSolution` (Client -> Server)\n\nUpon finding a coinbase transaction/nonce pair which double-SHA256 hashes at or below `SetNewPrevHash::target`, the client MUST immediately send this message, and the server MUST then immediately construct the corresponding full block and attempt to propagate it to the Bitcoin network.\n\n| Field Name       | Data Type | Description                                                                                                                                                                                                                                    |\n| ---------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| template_id      | U64       | The template_id field as it appeared in NewTemplate                                                                                                                                                                                            |\n| version          | U32       | The version field in the block header. Bits not defined by BIP320 as additional nonce MUST be the same as they appear in the NewMiningJob message, other bits may be set to any value.                                                              |\n| header_timestamp | U32       | The nTime field in the block header. This MUST be greater than or equal to the header_timestamp field in the latest SetNewPrevHash message and lower than or equal to that value plus the number of seconds since the receipt of that message. |\n| header_nonce     | U32       | The nonce field in the header                                                                                                                                                                                                                  |\n| coinbase_tx      | B0_64K    | The full serialized coinbase transaction, meeting all the requirements of the NewMiningJob message, above                                                                                                                                           |\n",
    "html": "<h1>7. Template Distribution Protocol</h1>\n<p>The Template Distribution protocol is used to receive updates of the block template to use in mining the next block.\nIt effectively replaces <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki\">BIP 22</a> and <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki\">BIP 23</a> (<code>getblocktemplate</code>) and provides a much more efficient API which allows Bitcoin Core (or some other full node software) to push template updates at more appropriate times as well as provide a template which may be mined on quickly for the block-after-next.\nWhile not recommended, the template update protocol can be a remote server, and is thus authenticated and signed in the same way as all other protocols (using the same SetupConnection handshake).</p>\n<p>Like the Job Declaration and Job Distribution protocols, all Template Distribution messages have the <code>channel_msg</code> bit unset, and there is no concept of channels.\nAfter the initial common handshake, the client MUST immediately send a <code>CoinbaseOutputConstraints</code> message to indicate the space it requires for coinbase output addition, to which the server MUST immediately reply with the current best block template it has available to the client.\nThereafter, the server SHOULD push new block templates to the client whenever the total fee in the current block template increases materially, and MUST send updated block templates whenever it learns of a new block.</p>\n<p>Template Providers MUST attempt to broadcast blocks which are mined using work they provided, and thus MUST track the work which they provided to clients.</p>\n<h2>7.1 <code>CoinbaseOutputConstraints</code> (Client -&gt; Server)</h2>\n<p>Ultimately, the pool is responsible for adding coinbase transaction outputs for payouts and other uses, and thus the Template Provider will need to consider this additional block size, and sigops when selecting transactions for inclusion in a block (to not create an invalid, oversized block).\nThus, this message is used to indicate that some additional space and sigops in the block/coinbase transaction be reserved for the pool’s use (while always assuming the pool will use the entirety of available coinbase space and sigops).</p>\n<p>The Job Declarator MUST discover the maximum serialized size of the additional outputs and sigops which will be added by the pool(s) it intends to use this work.\nIt then MUST communicate it to the Template Provider via this message.\nThe Template Provider MUST NOT provide <code>NewMiningJob</code> messages which would represent consensus-invalid blocks once this additional size and sigops — along with a maximally-sized (100 byte) coinbase script field — is added.\nFurther, the Template Provider MUST consider the maximum additional bytes required in the output count variable-length integer in the coinbase transaction when complying with the size limits.\nCurrent sigops limit per block in bitcoin is 80_000. We are not aware of any use cases where\ncoinbase have more the 65_535 so coinbase_output_max_sigops is an U16. Note that taproot outputs consume 0 sigops.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>coinbase_output_max_additional_size</td>\n<td>U32</td>\n<td>The maximum additional serialized bytes which the pool will add in coinbase transaction outputs</td>\n</tr>\n<tr>\n<td>coinbase_output_max_additional_sigops</td>\n<td>U16</td>\n<td>The maximum additional sigops which the pool will add in coinbase transaction outputs</td>\n</tr>\n</tbody>\n</table>\n<h2>7.2 <code>NewTemplate</code> (Server -&gt; Client)</h2>\n<p>The primary template-providing function. Note that the <code>coinbase_tx_outputs</code> bytes will appear as is at the end of the coinbase transaction.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>Server’s identification of the template. Strictly increasing, the current UNIX time may be used in place of an ID</td>\n</tr>\n<tr>\n<td>future_template</td>\n<td>BOOL</td>\n<td>True if the template is intended for future SetNewPrevHash message sent on the channel. If False, the job relates to the last sent SetNewPrevHash message on the channel and the miner should start to work on the job immediately.</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>Valid header version field that reflects the current network consensus. The general purpose bits (as specified in BIP320) can be freely manipulated by the downstream node. The downstream node MUST NOT rely on the upstream node to set the BIP320 bits to any particular value.</td>\n</tr>\n<tr>\n<td>coinbase_tx_version</td>\n<td>U32</td>\n<td>The coinbase transaction nVersion field</td>\n</tr>\n<tr>\n<td>coinbase_prefix</td>\n<td>B0_255</td>\n<td>Up to 8 bytes (not including the length byte) which are to be placed at the beginning of the coinbase field in the coinbase transaction</td>\n</tr>\n<tr>\n<td>coinbase_tx_input_sequence</td>\n<td>U32</td>\n<td>The coinbase transaction input’s nSequence field</td>\n</tr>\n<tr>\n<td>coinbase_tx_value_remaining</td>\n<td>U64</td>\n<td>The value, in satoshis, available for spending in coinbase outputs added by the client. Includes both transaction fees and block subsidy.</td>\n</tr>\n<tr>\n<td>coinbase_tx_outputs_count</td>\n<td>U32</td>\n<td>The number of transaction outputs included in coinbase_tx_outputs</td>\n</tr>\n<tr>\n<td>coinbase_tx_outputs</td>\n<td>B0_64K</td>\n<td>Bitcoin transaction outputs to be included as the last outputs in the coinbase transaction</td>\n</tr>\n<tr>\n<td>coinbase_tx_locktime</td>\n<td>U32</td>\n<td>The locktime field in the coinbase transaction</td>\n</tr>\n<tr>\n<td>merkle_path</td>\n<td>SEQ0_255[U256]</td>\n<td>Merkle path hashes ordered from deepest</td>\n</tr>\n</tbody>\n</table>\n<h2>7.3 <code>SetNewPrevHash</code> (Server -&gt; Client)</h2>\n<p>Upon successful validation of a new best block, the server MUST immediately provide a <code>SetNewPrevHash</code> message.\nIf a <code>NewMiningJob</code> message has previously been sent with an empty <code>min_ntime</code>, which is valid work based on the <code>prev_hash</code> contained in this message, the <code>template_id</code> field SHOULD be set to the <code>job_id</code> present in that <code>NewTemplate</code> message indicating the client MUST begin mining on that template as soon as possible.</p>\n<p>TODO: Define how many previous works the client has to track (2? 3?), and require that the server reference one of those in <code>SetNewPrevHash</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>template_id referenced in a previous NewTemplate message</td>\n</tr>\n<tr>\n<td>prev_hash</td>\n<td>U256</td>\n<td>Previous block’s hash, as it must appear in the next block’s header</td>\n</tr>\n<tr>\n<td>header_timestamp</td>\n<td>U32</td>\n<td>The nTime field in the block header at which the client should start (usually current time). This is NOT the minimum valid nTime value.</td>\n</tr>\n<tr>\n<td>nBits</td>\n<td>U32</td>\n<td>Block header field</td>\n</tr>\n<tr>\n<td>target</td>\n<td>U256</td>\n<td>The maximum double-SHA256 hash value which would represent a valid block. Note that this may be lower than the target implied by nBits in several cases, including weak-block based block propagation.</td>\n</tr>\n</tbody>\n</table>\n<h2>7.4 <code>RequestTransactionData</code> (Client -&gt; Server)</h2>\n<p>A request sent by the Job Declarator to the Template Provider which requests the set of transaction data for all transactions (excluding the coinbase transaction) included in a block, as well as any additional data which may be required by the Pool to validate the work.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>The template_id corresponding to a NewTemplate message</td>\n</tr>\n</tbody>\n</table>\n<h2>7.5 <code>RequestTransactionData.Success</code> (Server-&gt;Client)</h2>\n<p>A response to <code>RequestTransactionData</code> which contains the set of full transaction data and excess data required for validation.\nFor practical purposes, the excess data is usually the SegWit commitment, however the Job Declarator MUST NOT parse or interpret the excess data in any way.\nNote that the transaction data MUST be treated as opaque blobs and MUST include any SegWit or other data which the Pool may require to verify the transaction.\nFor practical purposes, the transaction data is likely the witness-encoded transaction today.\nHowever, to ensure backward compatibility, the transaction data MAY be encoded in a way that is different from the consensus serialization of Bitcoin transactions.</p>\n<p>Ultimately, having some method of negotiating the specific format of transactions between the Template Provider and the Pool’s Template verification node would be overly burdensome, thus the following requirements are made explicit.\nThe <code>RequestTransactionData.Success</code> sender MUST ensure that the data is provided in a forwards- and backwards-compatible way to ensure the end receiver of the data can interpret it, even in the face of new, consensus-optional data.\nThis allows significantly more flexibility on both the <code>RequestTransactionData.Success</code>-generating and -interpreting sides during upgrades, at the cost of breaking some potential optimizations which would require version negotiation to provide support for previous versions.\nFor practical purposes, and as a non-normative suggested implementation for Bitcoin Core, this implies that additional consensus-optional data be appended at the end of transaction data.\nIt will simply be ignored by versions which do not understand it.</p>\n<p>To work around the limitation of not being able to negotiate e.g. a transaction compression scheme, the format of the opaque data in <code>RequestTransactionData.Success</code> messages MAY be changed in non-compatible ways at the time a fork activates, given sufficient time from code-release to activation (as any sane fork would have to have) and there being some in-Template Negotiation Protocol signaling of support for the new fork (e.g. for soft-forks activated using <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki\">BIP 9</a>).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>The template_id corresponding to a NewTemplate/RequestTransactionData message</td>\n</tr>\n<tr>\n<td>excess_data</td>\n<td>B0_64K</td>\n<td>Extra data which the Pool may require to validate the work</td>\n</tr>\n<tr>\n<td>transaction_list</td>\n<td>SEQ0_64K[B0_16M]</td>\n<td>List of full transactions as requested by ProvideMissingTransactions, in the order they were requested in ProvideMissingTransactions</td>\n</tr>\n</tbody>\n</table>\n<h2>7.6 <code>RequestTransactionData.Error</code> (Server-&gt;Client)</h2>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>The template_id corresponding to a NewTemplate/RequestTransactionData message</td>\n</tr>\n<tr>\n<td>error_code</td>\n<td>STR0_255</td>\n<td>Reason why no transaction data has been provided</td>\n</tr>\n</tbody>\n</table>\n<p>Possible error codes:</p>\n<ul>\n<li><code>template-id-not-found</code> - used when the template being referenced is too old and no longer stored in the memory of the Template Provider</li>\n<li><code>stale-template-id</code> - used when the prev_hash of the corresponding template is still in the Template Provider’s memory, but it no longer points to the latest tip</li>\n</ul>\n<h2>7.7 <code>SubmitSolution</code> (Client -&gt; Server)</h2>\n<p>Upon finding a coinbase transaction/nonce pair which double-SHA256 hashes at or below <code>SetNewPrevHash::target</code>, the client MUST immediately send this message, and the server MUST then immediately construct the corresponding full block and attempt to propagate it to the Bitcoin network.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>template_id</td>\n<td>U64</td>\n<td>The template_id field as it appeared in NewTemplate</td>\n</tr>\n<tr>\n<td>version</td>\n<td>U32</td>\n<td>The version field in the block header. Bits not defined by BIP320 as additional nonce MUST be the same as they appear in the NewMiningJob message, other bits may be set to any value.</td>\n</tr>\n<tr>\n<td>header_timestamp</td>\n<td>U32</td>\n<td>The nTime field in the block header. This MUST be greater than or equal to the header_timestamp field in the latest SetNewPrevHash message and lower than or equal to that value plus the number of seconds since the receipt of that message.</td>\n</tr>\n<tr>\n<td>header_nonce</td>\n<td>U32</td>\n<td>The nonce field in the header</td>\n</tr>\n<tr>\n<td>coinbase_tx</td>\n<td>B0_64K</td>\n<td>The full serialized coinbase transaction, meeting all the requirements of the NewMiningJob message, above</td>\n</tr>\n</tbody>\n</table>\n"
  },
  "08-Message-Types": {
    "slug": "08-Message-Types",
    "content": "# 8. Message Types\n\n| Message Type (8-bit)           | channel_msg bit | Message Name                       |\n| ------------------------------ | --------------- | ---------------------------------- |\n| 0x00                           | 0               | SetupConnection                    |\n| 0x01                           | 0               | SetupConnection.Success            |\n| 0x02                           | 0               | SetupConnection.Error              |\n| 0x03                           | 1               | ChannelEndpointChanged             |\n| 0x04                           | 0               | Reconnect                          |\n| Mining Protocol                |                 |                                    |\n| 0x10                           | 0               | OpenStandardMiningChannel          |\n| 0x11                           | 0               | OpenStandardMiningChannel.Success  |\n| 0x12                           | 0               | OpenMiningChannel.Error            |\n| 0x13                           | 0               | OpenExtendedMiningChannel          |\n| 0x14                           | 0               | OpenExtendedMiningChannel.Success  |\n| 0x15                           | 0               | NewMiningJob                       |\n| 0x16                           | 1               | UpdateChannel                      |\n| 0x17                           | 1               | UpdateChannel.Error                |\n| 0x18                           | 1               | CloseChannel                       |\n| 0x19                           | 1               | SetExtranoncePrefix                |\n| 0x1a                           | 1               | SubmitSharesStandard               |\n| 0x1b                           | 1               | SubmitSharesExtended               |\n| 0x1c                           | 1               | SubmitShares.Success               |\n| 0x1d                           | 1               | SubmitShares.Error                 |\n| 0x1e                           | 1               | Reserved                           |\n| 0x1f                           | 1               | NewExtendedMiningJob               |\n| 0x20                           | 1               | SetNewPrevHash                     |\n| 0x21                           | 1               | SetTarget                          |\n| 0x22                           | 0               | SetCustomMiningJob                 |\n| 0x23                           | 0               | SetCustomMiningJob.Success         |\n| 0x24                           | 0               | SetCustomMiningJob.Error           |\n| 0x25                           | 0               | SetGroupChannel                    |\n| Job Declaration Protocol       |                 |                                    |\n| 0x50                           | 0               | AllocateMiningJobToken             |\n| 0x51                           | 0               | AllocateMiningJobToken.Success     |\n| 0x55                           | 0               | ProvideMissingTransactions         |\n| 0x56                           | 0               | ProvideMissingTransactions.Success |\n| 0x57                           | 0               | DeclareMiningJob                   |\n| 0x58                           | 0               | DeclareMiningJob.Success           |\n| 0x59                           | 0               | DeclareMiningJob.Error             |\n| 0x60                           | 1               | SubmitSolution                     |\n| Template Distribution Protocol |                 |                                    |\n| 0x70                           | 0               | CoinbaseOutputConstraints           |\n| 0x71                           | 0               | NewTemplate                        |\n| 0x72                           | 0               | SetNewPrevHash                     |\n| 0x73                           | 0               | RequestTransactionData             |\n| 0x74                           | 0               | RequestTransactionData.Success     |\n| 0x75                           | 0               | RequestTransactionData.Error       |\n| 0x76                           | 0               | SubmitSolution                     |\n",
    "html": "<h1>8. Message Types</h1>\n<table>\n<thead>\n<tr>\n<th>Message Type (8-bit)</th>\n<th>channel_msg bit</th>\n<th>Message Name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x00</td>\n<td>0</td>\n<td>SetupConnection</td>\n</tr>\n<tr>\n<td>0x01</td>\n<td>0</td>\n<td>SetupConnection.Success</td>\n</tr>\n<tr>\n<td>0x02</td>\n<td>0</td>\n<td>SetupConnection.Error</td>\n</tr>\n<tr>\n<td>0x03</td>\n<td>1</td>\n<td>ChannelEndpointChanged</td>\n</tr>\n<tr>\n<td>0x04</td>\n<td>0</td>\n<td>Reconnect</td>\n</tr>\n<tr>\n<td>Mining Protocol</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0x10</td>\n<td>0</td>\n<td>OpenStandardMiningChannel</td>\n</tr>\n<tr>\n<td>0x11</td>\n<td>0</td>\n<td>OpenStandardMiningChannel.Success</td>\n</tr>\n<tr>\n<td>0x12</td>\n<td>0</td>\n<td>OpenMiningChannel.Error</td>\n</tr>\n<tr>\n<td>0x13</td>\n<td>0</td>\n<td>OpenExtendedMiningChannel</td>\n</tr>\n<tr>\n<td>0x14</td>\n<td>0</td>\n<td>OpenExtendedMiningChannel.Success</td>\n</tr>\n<tr>\n<td>0x15</td>\n<td>0</td>\n<td>NewMiningJob</td>\n</tr>\n<tr>\n<td>0x16</td>\n<td>1</td>\n<td>UpdateChannel</td>\n</tr>\n<tr>\n<td>0x17</td>\n<td>1</td>\n<td>UpdateChannel.Error</td>\n</tr>\n<tr>\n<td>0x18</td>\n<td>1</td>\n<td>CloseChannel</td>\n</tr>\n<tr>\n<td>0x19</td>\n<td>1</td>\n<td>SetExtranoncePrefix</td>\n</tr>\n<tr>\n<td>0x1a</td>\n<td>1</td>\n<td>SubmitSharesStandard</td>\n</tr>\n<tr>\n<td>0x1b</td>\n<td>1</td>\n<td>SubmitSharesExtended</td>\n</tr>\n<tr>\n<td>0x1c</td>\n<td>1</td>\n<td>SubmitShares.Success</td>\n</tr>\n<tr>\n<td>0x1d</td>\n<td>1</td>\n<td>SubmitShares.Error</td>\n</tr>\n<tr>\n<td>0x1e</td>\n<td>1</td>\n<td>Reserved</td>\n</tr>\n<tr>\n<td>0x1f</td>\n<td>1</td>\n<td>NewExtendedMiningJob</td>\n</tr>\n<tr>\n<td>0x20</td>\n<td>1</td>\n<td>SetNewPrevHash</td>\n</tr>\n<tr>\n<td>0x21</td>\n<td>1</td>\n<td>SetTarget</td>\n</tr>\n<tr>\n<td>0x22</td>\n<td>0</td>\n<td>SetCustomMiningJob</td>\n</tr>\n<tr>\n<td>0x23</td>\n<td>0</td>\n<td>SetCustomMiningJob.Success</td>\n</tr>\n<tr>\n<td>0x24</td>\n<td>0</td>\n<td>SetCustomMiningJob.Error</td>\n</tr>\n<tr>\n<td>0x25</td>\n<td>0</td>\n<td>SetGroupChannel</td>\n</tr>\n<tr>\n<td>Job Declaration Protocol</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0x50</td>\n<td>0</td>\n<td>AllocateMiningJobToken</td>\n</tr>\n<tr>\n<td>0x51</td>\n<td>0</td>\n<td>AllocateMiningJobToken.Success</td>\n</tr>\n<tr>\n<td>0x55</td>\n<td>0</td>\n<td>ProvideMissingTransactions</td>\n</tr>\n<tr>\n<td>0x56</td>\n<td>0</td>\n<td>ProvideMissingTransactions.Success</td>\n</tr>\n<tr>\n<td>0x57</td>\n<td>0</td>\n<td>DeclareMiningJob</td>\n</tr>\n<tr>\n<td>0x58</td>\n<td>0</td>\n<td>DeclareMiningJob.Success</td>\n</tr>\n<tr>\n<td>0x59</td>\n<td>0</td>\n<td>DeclareMiningJob.Error</td>\n</tr>\n<tr>\n<td>0x60</td>\n<td>1</td>\n<td>SubmitSolution</td>\n</tr>\n<tr>\n<td>Template Distribution Protocol</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>0x70</td>\n<td>0</td>\n<td>CoinbaseOutputConstraints</td>\n</tr>\n<tr>\n<td>0x71</td>\n<td>0</td>\n<td>NewTemplate</td>\n</tr>\n<tr>\n<td>0x72</td>\n<td>0</td>\n<td>SetNewPrevHash</td>\n</tr>\n<tr>\n<td>0x73</td>\n<td>0</td>\n<td>RequestTransactionData</td>\n</tr>\n<tr>\n<td>0x74</td>\n<td>0</td>\n<td>RequestTransactionData.Success</td>\n</tr>\n<tr>\n<td>0x75</td>\n<td>0</td>\n<td>RequestTransactionData.Error</td>\n</tr>\n<tr>\n<td>0x76</td>\n<td>0</td>\n<td>SubmitSolution</td>\n</tr>\n</tbody>\n</table>\n"
  },
  "09-Extensions": {
    "slug": "09-Extensions",
    "content": "# 9. Extensions\n\nThere are not yet any defined extensions.\n| Extenstion Type | Extension Name | Description / BIP |\n| -------------------- | -------------- | ---------------------------------------------------------------------------- |\n| (no channel_msg bit) | | |\n",
    "html": "<h1>9. Extensions</h1>\n<p>There are not yet any defined extensions.</p>\n<table>\n<thead>\n<tr>\n<th>Extenstion Type</th>\n<th>Extension Name</th>\n<th>Description / BIP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(no channel_msg bit)</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n"
  },
  "10-Discussion": {
    "slug": "10-Discussion",
    "content": "# 10. Discussion\n## 10.1 Speculative Mining Jobs\nTBD Describe how exactly sending of new jobs before the next block is found works. \n\n## 10.2 Rolling `nTime`\n- `nTime `field can be rolled once per second with the following notes:\n- Mining proxy must not interpret greater than minimum `nTime` as invalid submission.\n- Device MAY roll `nTime` once per second.\n- Pool SHOULD accept `nTime` which is within the consensus limits.\n- Pool MUST accept `nTime` rolled once per second.\n\n### 10.2.1 Hardware `nTime` rolling\nThe protocol allows `nTime` rolling in the hardware as long as the hardware can roll the `nTime` field once per second.\n\nModern bitcoin ASIC miners do/will support `nTime` rolling in hardware because it is the most efficient way to expand hashing space for one hashing core/chip.\nThe `nTime` field is part of the second SHA256 block so it shares midstates with the nonce.\nRolling `nTime` therefore can be implemented as efficiently as rolling nonce, with lowered communication with a mining chip over its communication channels.\nThe protocol needs to allow and support this.\n\n## 10.3 Notes\n- Legacy mode: update extranonce1, don’t send all the time (send common merkle-root)\n- mining on a locally obtained prevhash (server SHOULD queue the work for some time if the miner has faster access to the network).\n- Proxying with separated channels helps with merging messages into TCP stream, makes reconnecting more efficient (and done in proxy, not HW), allows to negotiate work for all devices at once.\n- Evaluate reaching the design goals.\n- Add promise protocol extension support. It is mainly for XMR and ZEC, but can be addressed in generic way already.\n  Promise construction can be coin specific, but the general idea holds for all known use cases.\n\n## 10.4 Usage Scenarios\nv2 ST - protocol v2 (this), standard channel\n\nv2 EX - protocol v2, extended channel\n\nv1 - original stratum v1 protocol\n\n### 10.4.1 End Device (v2 ST)\nTypical scenario for end mining devices, header-only mining.\nThe device:\n\n- Sets up the connection without enabling extended channels.\n- Opens a Standard channel or more (in the future).\n- Receives standard jobs with Merkle root provided by the upstream node.\n- Submits standard shares.\n\n### 10.4.2 Transparent Proxy (v2 any -> v2 any)\nTranslation from v2 clients to v2 upstream, without aggregating difficulty.\n\nTransparent proxy (connection aggregation):\n\n- Passes all `OpenChannel` messages from downstream connections to the upstream, with updated `request_id` for unique identification.\n- Associates `channel_id` given by `OpenChannel.Success` with the initiating downstream connection.\n  All further messages addressed to the `channel_id` from the upstream node are passed only to this connection, with `channel_id` staying stable.\n\n### 10.4.3 Difficulty Aggregating Proxy (v2 any -> v2 EX)\nProxy:\n- Translates all standard ...\n\nV1 \n\n(todo difficulty aggregation with info about the devices)\n\n\n### 10.4.4 Proxy (v1 -> v2)\nTranslation from v1 clients to v2 upstream. \n\nThe proxy:\n- Accept Opens ...\n\n\n### 10.4.5 Proxy (v2 -> v1)\n...\n\n\n## 10.5 FAQ\n\n\n### 10.5.1 Why is the protocol binary?\nThe original stratum protocol uses json, which has very bad ratio between the payload size and the actual information transmitted.\nDesigning a binary based protocol yields better data efficiency.\nTechnically, we can use the saved bandwidth for more frequent submits to further reduce the variance in measured hash rate and/or to allow individual machines to submit its work directly instead of using work-splitting mining proxy.\n\n## 10.6 Terminology\n- **upstream stratum node**: responsible for providing new mining jobs, information about new prevhash, etc. \n- **downstream stratum node**: consumes mining jobs by physically performing proof-of-work computations or by passing jobs onto further downstream devices.\n- **channel ID**: identifies an individual mining device or proxy after the channel has been opened. Upstream endpoints perform job submission \n- **public key**: ...\n- **signature**: signature encoded as...(?)\n- **BIP320**: this proposal identifies general purpose bits within version field of bitcoin block header. Mining devices use these bits to extend their search space.\n- **Merkle root**: the root hash of a Merkle tree which contains the coinbase transaction and the transaction set consisting of all the other transactions in the block.\n\n## 10.7 Open Questions / Issues\n- Write more about channel ID being identifier valid for a particular connection only.\n  It works only in the namespace of it.\n- Refresh sequence diagrams.\n- Is it useful to have channel-based reconnect?\n  Or is connection-based enough?\n- Decide on how to control a single device and allow it to have open multiple channels. \n- Describe precisely scenarios with `SetNewPrevHash` with regards to repeated block height\n- Decide on how to manage assignment of message ID's and the size of the message ID space.\n  Shall we allow 2 level multiplexing?\n  E.g. dedicate an ID to a class of vendor messages, while allowing the vendor to assign custom messages ID’s within the class?\n- More information about telemetry data\n\n```\n+----------------------------------------------------------------------------------------------------------------------+\n|                                                 Hashing Power Information                                            |\n+-------------------------+------------------+-------------------------------------------------------------------------+\n| Field Name              | Data Type        | Description                                                             |\n+-------------------------+------------------+-------------------------------------------------------------------------+\n| aggregated_device_count | U32              | Number of aggregated devices on the channel. An end mining device must  |\n|                         |                  | send 1. A proxy can send 0 when there are no connections to it yet (in  | \n|                         |                  | aggregating mode) \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   | \n+-------------------------+------------------+-------------------------------------------------------------------------+\n```\n",
    "html": "<h1>10. Discussion</h1>\n<h2>10.1 Speculative Mining Jobs</h2>\n<p>TBD Describe how exactly sending of new jobs before the next block is found works.</p>\n<h2>10.2 Rolling <code>nTime</code></h2>\n<ul>\n<li><code>nTime </code>field can be rolled once per second with the following notes:</li>\n<li>Mining proxy must not interpret greater than minimum <code>nTime</code> as invalid submission.</li>\n<li>Device MAY roll <code>nTime</code> once per second.</li>\n<li>Pool SHOULD accept <code>nTime</code> which is within the consensus limits.</li>\n<li>Pool MUST accept <code>nTime</code> rolled once per second.</li>\n</ul>\n<h3>10.2.1 Hardware <code>nTime</code> rolling</h3>\n<p>The protocol allows <code>nTime</code> rolling in the hardware as long as the hardware can roll the <code>nTime</code> field once per second.</p>\n<p>Modern bitcoin ASIC miners do/will support <code>nTime</code> rolling in hardware because it is the most efficient way to expand hashing space for one hashing core/chip.\nThe <code>nTime</code> field is part of the second SHA256 block so it shares midstates with the nonce.\nRolling <code>nTime</code> therefore can be implemented as efficiently as rolling nonce, with lowered communication with a mining chip over its communication channels.\nThe protocol needs to allow and support this.</p>\n<h2>10.3 Notes</h2>\n<ul>\n<li>Legacy mode: update extranonce1, don’t send all the time (send common merkle-root)</li>\n<li>mining on a locally obtained prevhash (server SHOULD queue the work for some time if the miner has faster access to the network).</li>\n<li>Proxying with separated channels helps with merging messages into TCP stream, makes reconnecting more efficient (and done in proxy, not HW), allows to negotiate work for all devices at once.</li>\n<li>Evaluate reaching the design goals.</li>\n<li>Add promise protocol extension support. It is mainly for XMR and ZEC, but can be addressed in generic way already.\nPromise construction can be coin specific, but the general idea holds for all known use cases.</li>\n</ul>\n<h2>10.4 Usage Scenarios</h2>\n<p>v2 ST - protocol v2 (this), standard channel</p>\n<p>v2 EX - protocol v2, extended channel</p>\n<p>v1 - original stratum v1 protocol</p>\n<h3>10.4.1 End Device (v2 ST)</h3>\n<p>Typical scenario for end mining devices, header-only mining.\nThe device:</p>\n<ul>\n<li>Sets up the connection without enabling extended channels.</li>\n<li>Opens a Standard channel or more (in the future).</li>\n<li>Receives standard jobs with Merkle root provided by the upstream node.</li>\n<li>Submits standard shares.</li>\n</ul>\n<h3>10.4.2 Transparent Proxy (v2 any -&gt; v2 any)</h3>\n<p>Translation from v2 clients to v2 upstream, without aggregating difficulty.</p>\n<p>Transparent proxy (connection aggregation):</p>\n<ul>\n<li>Passes all <code>OpenChannel</code> messages from downstream connections to the upstream, with updated <code>request_id</code> for unique identification.</li>\n<li>Associates <code>channel_id</code> given by <code>OpenChannel.Success</code> with the initiating downstream connection.\nAll further messages addressed to the <code>channel_id</code> from the upstream node are passed only to this connection, with <code>channel_id</code> staying stable.</li>\n</ul>\n<h3>10.4.3 Difficulty Aggregating Proxy (v2 any -&gt; v2 EX)</h3>\n<p>Proxy:</p>\n<ul>\n<li>Translates all standard …</li>\n</ul>\n<p>V1</p>\n<p>(todo difficulty aggregation with info about the devices)</p>\n<h3>10.4.4 Proxy (v1 -&gt; v2)</h3>\n<p>Translation from v1 clients to v2 upstream.</p>\n<p>The proxy:</p>\n<ul>\n<li>Accept Opens …</li>\n</ul>\n<h3>10.4.5 Proxy (v2 -&gt; v1)</h3>\n<p>…</p>\n<h2>10.5 FAQ</h2>\n<h3>10.5.1 Why is the protocol binary?</h3>\n<p>The original stratum protocol uses json, which has very bad ratio between the payload size and the actual information transmitted.\nDesigning a binary based protocol yields better data efficiency.\nTechnically, we can use the saved bandwidth for more frequent submits to further reduce the variance in measured hash rate and/or to allow individual machines to submit its work directly instead of using work-splitting mining proxy.</p>\n<h2>10.6 Terminology</h2>\n<ul>\n<li><strong>upstream stratum node</strong>: responsible for providing new mining jobs, information about new prevhash, etc.</li>\n<li><strong>downstream stratum node</strong>: consumes mining jobs by physically performing proof-of-work computations or by passing jobs onto further downstream devices.</li>\n<li><strong>channel ID</strong>: identifies an individual mining device or proxy after the channel has been opened. Upstream endpoints perform job submission</li>\n<li><strong>public key</strong>: …</li>\n<li><strong>signature</strong>: signature encoded as…(?)</li>\n<li><strong>BIP320</strong>: this proposal identifies general purpose bits within version field of bitcoin block header. Mining devices use these bits to extend their search space.</li>\n<li><strong>Merkle root</strong>: the root hash of a Merkle tree which contains the coinbase transaction and the transaction set consisting of all the other transactions in the block.</li>\n</ul>\n<h2>10.7 Open Questions / Issues</h2>\n<ul>\n<li>Write more about channel ID being identifier valid for a particular connection only.\nIt works only in the namespace of it.</li>\n<li>Refresh sequence diagrams.</li>\n<li>Is it useful to have channel-based reconnect?\nOr is connection-based enough?</li>\n<li>Decide on how to control a single device and allow it to have open multiple channels.</li>\n<li>Describe precisely scenarios with <code>SetNewPrevHash</code> with regards to repeated block height</li>\n<li>Decide on how to manage assignment of message ID’s and the size of the message ID space.\nShall we allow 2 level multiplexing?\nE.g. dedicate an ID to a class of vendor messages, while allowing the vendor to assign custom messages ID’s within the class?</li>\n<li>More information about telemetry data</li>\n</ul>\n<pre><code>+----------------------------------------------------------------------------------------------------------------------+\n|                                                 Hashing Power Information                                            |\n+-------------------------+------------------+-------------------------------------------------------------------------+\n| Field Name              | Data Type        | Description                                                             |\n+-------------------------+------------------+-------------------------------------------------------------------------+\n| aggregated_device_count | U32              | Number of aggregated devices on the channel. An end mining device must  |\n|                         |                  | send 1. A proxy can send 0 when there are no connections to it yet (in  | \n|                         |                  | aggregating mode) \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   | \n+-------------------------+------------------+-------------------------------------------------------------------------+\n</code></pre>\n"
  }
}